\section{Requirements}

\subsection{Overview}

The requirements package supports the collection of requirements and
traceability from arbitrary code back to the requirements.

\subsection{Specifying Requirements}

Requirements can be collected in instances of \ic{RequirementsModule}, a root
concept defined by the \ic{com.mbeddr.cc.requirements} language. An example is
shown in \fig{requirements1}. Each requirement has an ID, a short prose summary,
and a kind. (\ic{functional}, \ic{timing}). The kind, however, is more than just
a text; each kind comes with its own additional specifications. For example, a
\ic{timing} requirement requires users to enter a \ic{timing} specification.
This way, additional formal data can be collected for each kind of requirement.
 

\begin{figure}[h]
\begin{center} 
  \includegraphics[width=12cm]{figures/requirements1.png}
\end{center}
\label{requirements1}
\caption{Working with Requirements}
\end{figure}


In addition to the summary information discussed above, requirements can also
contains details. The details editor can be opened on a requirement with an
intention or with \keystroke{Ctrl-Shift-D}. \fig{requirements2} shows an
example.

\begin{figure}[h]
\begin{center} 
  \includegraphics[width=10cm]{figures/requirements2.png}
\end{center}
\label{requirements2}
\caption{Requirements editor expanded}
\end{figure}

In the details, a requirement can be described with additional prose, with the
kind-specific formal descriptions as well as with additional constraints among
requirements. The default hierarchical structure represents refinement: child
requirements refine the parent requirements. In addition, each requirement can
have typed links relative to other requirement, such as the \ic{conflicts with}
shown in \fig{requirements1}.


Requirements modules can import other reqirements modules using the \ic{import}
section. This way, large sets of requirements can be modularized.




\subsubsection{Extending the Requirements Language}

To extend the requirements framework, create a new language that extends
\ic{com.mbeddr.cc.requirements}. Then, use this language in the project that
manages your requirements.

\paragraph{A new Link} To create a new link, create a concept that extends
\ic{RequirementsLink}. It base class already comes with a pointer to the target
requirement. Just define the concept and an alias.

\paragraph{A new Kind} To create a new requirements kind, extend
\ic{RequirementsKind} and define an alias. 

\begin{figure}[h] 
\begin{center} 
  \includegraphics[width=12cm]{figures/reqkind.png}
\end{center}
\label{reqkind}
\caption{Defining additional required specifications for a requirements kind.}
\end{figure}

\paragraph{A new Additional Specification} Defining new additional
specifications (such as the \ic{timing} specification mentioned above) happens
in two steps. First you have to create a new concept that extends
\ic{RequirementsData}. It should contain any additional structure you need
(this can be a complete MPS DSL, or just a set of pointers to other
nodes). You should also define an alias. The second step requires enforcing that
a certain requirements kind also requires that particular additional
specification. In the respective kind, use the \ic{requiredDataKind} concept
link to point to the concept whose instance is required. \fig{reqkind} shows an
example.




\begin{figure}[h] 
\begin{center} 
  \includegraphics[width=7cm]{figures/trace.png}
\end{center}
\label{trace}
\caption{Code with requirements traces}
\end{figure}

\subsection{Tracing}

Tracing establishes links between implementation artifacts (i.e. arbitrary MPS
nodes) and requirements. The trace facilities are implemented in the \\
\ic{com.mbeddr.cc.trace} language. \fig{trace} shows an example of requirements
traces.

Traces can be attached to any MPS node using an intention. However, for this to
work, the root owning the current node has to have a reference to a requirements
module. This can be added using an intention. Only the requirements in the
referenced modules can be referred to from a trace. 

There is a second way to attach a trace to a program element: go to the target
requirement and copy it (\keystroke{Ctrl-C}). Then select one or more program
nodes and press \keystroke{Ctrl-Shift-R}. This will attach a trace from each of
these elements to the copied requirement.

A trace can have a kind. By default, the kind is \ic{trace}. However, the kind
can be changed (\keystroke{Ctrl-Space} on the \ic{trace} keyword.)
 
\subsubsection{Extending the Trace Facilities}

New trace kinds can be added by creating a new language that extends
\ic{com.mbeddr.cc.trace}, using that language from your application code, 
and defining a new concept that extends \ic{TraceKind}.


\subsection{Other Traceables}

The tracing framework cannot just trace to requirements, but to any concept that
implements \ic{ITraceTarget}. For example, a functional model may be used as a
trace target for implementation artifacts. In this section we explain briefly
how new trace targets can be implemented. We suggest you also take a look at
implementation of \ic{com.mbeddr.cc.requirements}, since this uses the same
facilities.

\begin{itemize}
  \item Concepts that should act as a trace target must implement the
  \ic{ITraceTarget} interface (e.g. \ic{Requirement})
  \item The root concept that contains the \ic{ITraceTarget}s must implement the
  \ic{ITraceTargetProvider} and implement the method \ic{allTraceTargets}.
  \item In addition, you have to create a concept that extends
  \ic{TraceTargetProvider-\\RefAttr}. It references \ic{ITraceTargetProvider}s. 
\end{itemize}

Here is how the whole system works: You attach a \ic{TraceAnnotation} to a
program element. It contains a set of \ic{TranceTargetRef}s which in turn
reference \ic{ITraceTarget}s. To find the candidate trace targets, the scoping
rule of \ic{TranceTargetRef} ascends the tree to the current root and checks if
it has something in the \ic{traceTargetProviderAttr} attribute. That would have
to be a subtype of \ic{TraceTargetProviderRefAttr}. It then follows the
\ic{ref}s references to a set of \ic{ITraceTargetProvider} and asks those for
the candidate \ic{ITraceTarget}.



\subsection{Evaluating the Traces in Reverse}

The traces can be evaluated in reverse order. For example, \fig{traceReverse}
(left) shows how requirements can be color-coded to reflect their state. The
color codes must be updated explicitly (may take a while) by the \ic{Update
Trace Stats} intention on the requirement module.

In addition, MPS Find Usages functionality has been enhanced for requirements.
If the user executes Find Usages for requirements, the various kinds of traces
are listed separately in the result (\fig{traceReverse}, right).

\begin{figure}[h]
\begin{center} 
  \includegraphics[width=110mm]{figures/traceReverse.png}
\end{center}
\label{traceReverse}
\caption{\textbf{Left:} The requirements can be color coded to reflect whether
they are traced at all (grey), implemented (blue) and testes (green). Untraced requirements are
red. \textbf{Right:} The Find Usages dialog shows the different kinds of traces
as separate categories.}
\end{figure} 

























 