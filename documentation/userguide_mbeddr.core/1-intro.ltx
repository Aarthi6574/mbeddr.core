
\vspace{50mm}


\begin{center} 
  \includegraphics{logoWithSlogan.png}

\vspace{5mm}
This document is part of the \\ 
mbeddr project at \ic{http://mbeddr.com}. 

\vspace{5mm}
This document is licensed under the \\ 
Eclipse Public License 1.0 (EPL).
\end{center}



\newpage


\setcounter{tocdepth}{2}
\tableofcontents
 
\newpage


\section{Language Use vs. Language Development}

This document focuses on the C programmer who wants to exploit the benefits of
the extensions to C provided by mbeddr. We assume that you have some knowledge
of regular C (such asK\&R C, ANSI C or C99). We also assume that you realize
some of the shortfalls of C and are "open" to the improvements in mbeddr C. The
main point of mbeddr C is the ability to extend it with domain-specific
concepts such as state machines, components, or whatever you deem useful in your
domain. We have also removed some of the "dangerous" features of C that are
often prohibited from use in real world projects. 

This document covers mbeddr \emph{core}, which is mainly a subset of the C
language for MPS. We do not discuss any extensions of the C language for
development in the embedded area, such as e.g. support for statemachines, type
safe units etc. These will be discussed in separate documents once they become
available.

\greyboxnote{As of now, these extension modules are not yet released. They have
to be polished further. They will become available in 2012.}
  
This document does not discuss how to develop new languages or extend existing
languages. We refer to the \emph{Extension Guide} instead. It is available from
\ic{http://mbeddr.com}.


 
\section{Installation}

At this point we don't yet provide an all-in-one download package. This is
because (a) we didn't get around to building one yet, and (b) as a consequence
of a number of open legal issues regarding re-packaging some of the third-party
tools used by mbeddr. However, this documentation describes the installation
process in detail.

\subsection{Java} 

MPS is a Java application. So as the first step, you have to install a Java
Development Kit version 1.6 or greater (JDK 1.6). You can get it from here \\
\hspace*{5mm}\ic{http://www.oracle.com/technetwork/java/javase/downloads/index.html}

\subsection{JetBrains Meta Programming System (MPS)} 

The mbeddr system is based on JetBrains MPS, an open source language workbench
available from \ic{http://www.jetbrains.com/mps/}. MPS is available for Windows,
Mac and Linux, and we require the use of the 2.0.4 version. Please make sure you
install MPS in a path that does not contains blanks in any of its directory or
file names (not even in the \ic{MPS 2.0} folder). This will simplify some of the
command line work you may want to do.

After installing MPS using the platform-specific installer, please open the
\ic{bin} folder and edit the \ic{mps.vmoptions}  or \ic{mps.exe.vmoptions} file
(depending on your platform). To make MPS run smoothly, the \ic{MaxPermSize}
setting should be increased to \ic{512m}. It should look like this
after the change:

\begin{code}
-client
-Xss1024k 
-ea
-Xmx1200m
-XX:MaxPermSize=512m
-XX:+HeapDumpOnOutOfMemoryError
-Dfile.encoding=UTF-8
\end{code}

On some 32bit Windows XP systems we had to reduce the \ic{-Xmx1200m} setting to
\ic{768m} to get it to work.


\subsection{GCC and make}

The mbeddr toolkit relies on \ic{gcc} and \ic{make} for compilation (unless you
use a different, target-specific build process). 

\begin{itemize}
  \item On Mac you should install XCode to get gcc, make and the associated tools.
  \item On Linux, these tools should be installed by default.
  \item On Windows we recommend installing cygwin
     (\ic{http://www.cygwin.com/}), a Unix-like environment for Windows. When
selecting the packages to be installed, make sure \ic{gcc-core} and \ic{make}
are included (both of them are in the \ic{Devel} subtree in the selection
dialog). The \ic{bin} directory of your cygwin installation has to be added to the system
\ic{PATH} variable; either globally, or in the script that starts up MPS (MPS
runs \ic{make}, so it has to be visible to MPS). On Windows, the \ic{mps.bat}
file in the MPS installation folder would have to be adapted like this:
\end{itemize}
 
\begin{code}
::rem mbeddr depends on Cygwin: gcc, make etc
::rem adapt the following to your cygwin bin path
set PATH=C:\ide\Cygwin\bin;%PATH%
\end{code}

\subsection{Graphviz}

MPS supports visualization of models via graphviz, directly embedded in MPS. To
use it, you have to install graphviz from \ic{http://graphviz.org}. We use
version 2.28. After the installation, you have to put the \ic{bin} directory of
graphviz into the path. Either globally, or by modifying the MPS startup script
in the same way as above:

\begin{code}
::rem mbeddr depends on graphviz dot
::rem adapt the following to your graphviz bin path
set PATH=C:\ide\graphviz2.28\bin;%PATH%
\end{code}

\subsection{mbeddr}

You can get the mbeddr code either via distributions or via the public github
repository.

\begin{description}
  \item[Distribution] You can get the mbeddr system via a zip file download
from \\\ic{http://mbeddr.wordpress.com/getit/} Save the zip file into a folder
on your hard disk and unzip it. Once again, please make sure the path to the
unzipped folder contains no blanks!
  \item[github] The github repo ist a
\ic{https://github.com/mbeddr/mbeddr.core}. You can clone it for your own use,
or you can fork it to your own github account so you can make changes. Contact
us if you want to become a committer.
\end{description}


\subsection{Debugger}

The mbeddr debugger is based on \ic{gdb}, which has been installed as part of
the Cygwin install. However, we don't use \ic{gdb} directly; rather we use the
Eclipse CDT debug bridge. This contains a native code, and Java has to be able
to find this native code. Hence, the \ic{java.library.path} property has to be
set as part of the MPS JVM startup. It has to point to a path that depends on
your OS platform. 

Open the mps startup script (\ic{.bat} or \ic{.sh}) and look for the line that
begins with

\begin{code}
set ADDITIONAL_JVM_ARGS=
\end{code}

It should be used to set the property, as shown in the following code (keep it
in one line!):

\begin{code}
set ADDITIONAL_JVM_ARGS=-Djava.library.path=
  "<mbeddr-root>/code/languages/com.mbeddr.core/languages/com.mbeddr.core.debug/lib/spawner/<os>"
\end{code}

The \ic{<mbeddr-root>} points to the root directory of the mbeddr languages as
cloned from github or unzipped after download. \ic{<os>} has to be set
specifically for your platform, it can be any of \ic{linux.x86},
\ic{linux.x86\_64}, \ic{macosx..x86\_64}, \ic{macosx.ppc}, \ic{macosx.x86},
\ic{win32.x86}, \ic{win32.x86\_64}. We suggest you take a look at the respective directory
structure to better understand what's going on.

The debugger needs a special library to control the \ic{gdb} process. We
packaged this library into a MPS plugin named \emph{spawner}. Please download this plugin 
from \url{bit.ly/K8HPD2} and unzip it into the \ic{plugins} directory of your
MPS installation.


\section{Important keyboard shortcuts in MPS and mbeddr}

\subsection{MPS in general}

MPS is a projectional editor. It does not parse text and build an Abstract
Syntax Tree (AST). Instead the AST is created directly by user editing actions,
and what you see in terms of text (or other notations) is a projection. This has
many advantages, but it also means that some of the well-known editing gestures
we know from normal text editing don't work. So in this section we explain some
keyboard shortcuts that are essential to work with MPS.

Since the very first experience a projectional editor is somewhat
different from what you are accustomed to in a text editor, we recommend
you watch the following screencast:\\
\hspace*{10mm} \ic{http://www.youtube.com/watch?v=wgsY3-ZX\_fs}  


\paragraph{Entering Code} In MPS you can only enter code that is
available from the code completion menu. Using aliases and other "tricks", MPS
manages to make this feel \emph{almost} like text editing. Here are some hints
though:

\begin{itemize}
  \item As you start typing, the text you're entering remains red, with a light
  red background. This means the string you've entered has not yet \emph{bound}. 
  \item Entered text will bind if there is only one thing left in the code
  completion menu that starts with the substring you've typed so far. An
  instance of the selected concept will be created and the red goes away.
  \item As long as text is still red, you can press \keystroke{Ctrl-Space} to
  explicitly open the code completion menu, and you can select from those
  concepts that start with the substring you have typed in so far.
  \item If you want to go back and enter something different from what the
  entered text already preselects, press \keystroke{Ctrl-Space} again. This will
  show the whole code completion menu.
  \item Finally, if you're trying to enter something that does not bind at all
  because the prefix you've typed does not match anything in the code
  completion menu, there is no point in continuing to type; it won't ever bind.
  You're probably trying to enter something that is not valid in this place.
  Maybe you haven't included the language module that provides the concept
  you have in mind?
\end{itemize}


\paragraph{Navigation} Navigation in the source works as usual using the cursor
keys or the mouse. References can be followed ("go to definition") either by
\keystroke{Ctrl-Click} or by using \keystroke{Ctrl-B}.


\paragraph{Selection} Selection is different. \keystroke{Ctrl-Up/Down} can be
used to select along the tree. For example consider a local variable declaration
\ic{int x = 2 + 3 * 4;} with the cursor at the \ic{3}. If you now press
\keystroke{Ctrl-Up}, the \ic{3 * 4} will be selected because the \ic{*} is the
parent of the \ic{3}. Pressing \keystroke{Ctrl-Up} again selects \ic{2 + 3 * 4},
and the next \keystroke{Ctrl-Up} selects the whole local variable declaration.

You can also select with \keystroke{Shift-Up/Down}. This selects siblings in a
list. For example, consider a statement list as in a function body ...

\begin{code}
void aFunction() {
  int x;
  int y;
  int z;
}
\end{code}

... and imagine the cursor in the \ic{x}. You can press \keystroke{Ctrl-Up} once
to select the whole \ic{int x;} and then you can use \keystroke{Shift-Down} to
select the \ic{y} and \ic{z} siblings. Note that the screencast mentioned above
illustrates these things much clearer.

\paragraph{Deleting Things} The safest way to delete something is to mark it
(using the strategies discussed in the previous paragraph) and the press
\keystroke{Backspace} or \keystroke{Delete}. In many places you can also simply
press \keystroke{Backspace} behind or \keystroke{Delete} before the thing you
want to delete.


\paragraph{Intentions} Some editing functionalities are not available via
"regular typing", but have to be performed via what's traditionally known as a
quick fix. In MPS, those are called intentions. The intentions menu can be shown
by pressing \keystroke{Alt-Enter} while the cursor is on the program element for
which the intention menu should be shown (each language concept element has its
own set of intentions). For example, module contents in mbeddr can only be set
to be \ic{exported} by selecting \emph{export} from the intentions menu. Explore
the contents of the intentions menu from time to time to see what's possible.

Note that you can just type the name of an intention once the menu is open, you
don't have to use the cursor keys to select from the list. So, for example, to
export a module content (function, struct), you type 
\keystroke{Alt-Enter}, \keystroke{ex}, \keystroke{Enter}. 

\paragraph{Surround-With Intentions} Surround-With intentions are used to
surround a selection with another construct. For example, if you select a couple
of lines (i.e. a list of statements) in a C program, you can then surround these
statements with an \ic{if} or with a \ic{while}. Press \keystroke{Ctrl-Alt-T}
to show the possible surround options at any time. To reemphasize: in contrast
to regular intentions which are opened by \keystroke{Alt-Enter}, surround-with
intentions can work on a selection that contains several nodes!

\paragraph{Refactorings} For many language constructs, refactorings are
provided. Refactorings are more important in MPS than in "normal" text editors,
because some (actually quite few) editing operations are hard to do manually.
Please explore the refactorings context menu, and take note when we explain
refactorings in the user's guide. Unlike intentions, which cannot have a
specific keyboard shortcut assigned, refactorings can, and we make use of this
feature heavily. The next section introduces some of these.


\subsection{mbeddr specific shortcuts}

\paragraph{Documentation} Many program elements can be documented. Examples
include statements, functions, global variables or structs. A
documentation is basically free text associated with a program element. 

We distinguish documentation from commenting out code (explained below). A
documentation is shown as a grey comment above the commented element (the
documentation is really attached to the element, and not just written into a
line above it --- a subtle but important difference!)


\begin{center} 
  \includegraphics[width=9cm]{figures/documentation.jpg}
\end{center}

Documentation can be added using the \emph{Add Documentation} intention, or by
using \keystroke{Ctrl-Alt-D} on the respective element.

Note that comments are only shown if they are turned on. You can use the context
menu on any program element and select $Toggle Docs$ to enable/disable display
of comments. As soon as a comment is added, comment display is automatically
turned on.


\paragraph{Commenting out Code} Code that is commented out retains its syntax
highlighting, but is shaded with a grey background. 

\begin{center} 
  \includegraphics[width=9cm]{figures/commenting.jpg}
\end{center}

Code can be commented out by pressing \keystroke{Ctrl-Alt-C} (this is
technically a refactoring, so this feature is also availale from the
refactorings context menu). This also works for lists of elements. Commented out
code can be commented back in by pressing \keystroke{Ctrl-Alt-C} on the comment
itself (the \ic{//}) or the commented element. 

Commenting out code is a bit different than in regular, textual systems because
code that is commented out is still "live": it is still stored as a tree, code
completion still works in it, it may still be shown in $Find References$, and
refactorings may affect the code. We are not sure if this is a desirable feature
and we are looking for your feedback. Of course, the code is not executed. All
commented program elements are removed during code generation.

\greyboxnote{The current implementation of comments is still a little bit of a
hack since we are waiting for some direct support by MPS. For example, errors
should not be shown in commented code, and we are sure other quirks will arise
as we continue using mbeddr.}

Not all program elements can be commented out (since special support by the
language is necessary to make something commentable), only concepts that
implement \ic{ICommentable} can be commented. At this time, this is all
statements and module contents.
