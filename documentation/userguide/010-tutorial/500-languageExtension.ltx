\chapter{Extending mbeddr}

This chapter discusses the \emph{extension} of the mbeddr system by developing
new languages or extending C. The chapter is essentially a collection of various
example languages that each explain different aspects; there is also some
overlap, i.e. some things may be explained more than once. 

This chapter is not intended as a complete MPS tutorial, although, of course, by
explaining how to build mbeddr extensions, we implicitly explain MPS. However,
we do recommend to take a look at some of the tutorials on the MPS website. In
particular, we recommend reading the LWC11 tutorial at

\ \ \ \ic{http://code.google.com/p/mps-lwc11/wiki/GettingStarted}

We also recommend reading a paper that explains the various
approaches for language composition:

\ \ \ \ic{http://voelter.de/data/pub/Voelter-GTTSE-MPS.pdf}

The latter paper is also available as a set of narrated screencasts. Please
watch them in this order:

\ \ \ \ic{http://www.youtube.com/watch?v=lNMRMZk8KBE}\\
\vspace{-10mm}

\ \ \ \ic{http://www.youtube.com/watch?v=ObWBUvHHNNg}\\
\vspace{-10mm}

\ \ \ \ic{http://www.youtube.com/watch?v=Y\_KvApgKZZQ}\\
\vspace{-10mm}

\ \ \ \ic{http://www.youtube.com/watch?v=0vELEMU\_Efc}\\
\vspace{-10mm}

\ \ \ \ic{http://www.youtube.com/watch?v=2\_6DzD73qDs}\\
\vspace{-10mm}

\ \ \ \ic{http://www.youtube.com/watch?v=4vUkbzRHF2Q}\\
\vspace{-10mm}

\ \ \ \ic{http://www.youtube.com/watch?v=Z23-Vpy6RFY}\\
\vspace{-10mm}

\ \ \ \ic{http://www.youtube.com/watch?v=HbnttNqXpdM}\\
 

\section{Overview over C Extensions}

In this section we discuss in which particular ways C needs to be extensible in
order to create meanngful language extensions. We then discuss a set of examples
and how to build them. This section is intended as an overview; more detailed
explanations follow below.

\subsection{Ways to Extend C}

\parhead{Top Level Constructs} Top level constructs (on the level of
functions or \ic{struct} declarations) are necessary. This enables the
integration of test cases or new programming paradigms relevant in particular
domains such as state machines, or interfaces and components.

\parhead{Statements} New statements, such as \ic{assert} or \ic{fail}
statements in test cases, must be supported. If statements introduce new
blocks, then variable visibility and shadowing must be handled correctly, just
as in regular C. Statements may have to be restricted to a specific
context; for example the \ic{assert} or \ic{fail} statements must
\emph{only} be used in test cases and not in any other statement list.

\parhead{Expressions} New kinds of expressions must be supported. An
example is a decision table expression that represents a two-level decision
tree as a two dimensional table. 

\parhead{Types and Literals} New types, e.g. for matrices,
complex numbers or quantities with physical units must be supported. This also
requires defining new operators and overriding the typing rules for existing
ones. New literals may also be required: for example, physical units could be
attached to number literals (as in \ic{10kg}).

\parhead{Transformation} Alternative transformations for existing
language concepts must be possible. For example, in a module marked as
\ic{safe}, \ic{x + y} may have to be translated to
\ic{addWithBoundsCheck(x, y)}, a call to an \ic{inline} function that performs
bounds-checking besides the addition. 

\parhead{Meta Data Decoration} It should be possible to add meta data
such as trace links to requirements or product line variability constraints to
arbitrary program nodes, without changing the concept of the node.

\parhead{Restriction} It should be possible to define contexts that
restrict the use of certain language concepts. Like
any other extension, such contexts must be definable \emph{after} the original language
has been implemented, without invasive change. For example, the use of
pointer arithmetic should be prohibited in modules marked as \emph{safe} or the
use of real numbers should be prohibited in state machines that are intended to
be model checked (model checkers do not support real numbers).


\subsection{Example Extensions}


\parhead{Unit Tests} Unit Tests are new top-level
constructs (\fig{testcase}) introduced in a separate \emph{unittest}
language that extends the C core. They are like \ic{void} functions without
arguments. The \emph{unittest} language also introduces \ic{assert} and
\ic{fail} statements, which can only be used inside test cases. Testing
embedded software can be a challenge, and the \emph{unittest} extension is a
first step at providing comprehensive support for testing. mbeddr also provides
support for platform-independent logging as well as for specifying stubs and
mocks. We do not discuss this in this paper.

 

\begin{figure}[h]  
\begin{center}
\includegraphics[scale=1]{figures/tutorial/unittest.png}
\end{center}
\caption{The \emph{unittest} language introduces test cases as well as
\ic{assert} and \ic{fail} statements which can only be used inside of a test
case. Test cases are transformed to functions, and the \ic{assert} statements
become \ic{if} statements with a negated condition. The generated code also
counts the number of failures so it can be reported to the user via a binary's
exit value.}
\vspace{-3mm}
\label{testcase}

\end{figure} 



\parhead{Decision Tables} Decision Tables are an example of extending
expressions. An example is shown in \fig{dectab}. A decision table represents
nested \ic{if} statements. It is evaluated to the value of the first cell whose
column and row headers are \ic{true} (the evaluation order is left to right, top
to bottom). A default value (\ic{FAIL}) is specified to handle the case where
none of the column/row header combinations is \ic{true}. Since the compiler and
IDE have to compute a type for expressions, the decision table specifies the
type of its result values explicitly (\ic{int8}).

\begin{figure}[h]
\begin{center}
\includegraphics[scale=1]{figures/tutorial/dectabexample.png} 
\end{center}
\caption{A decision
table evaluates to the value in the cell for which the row and column headers are
\ic{true}, a default value otherwise (\ic{FAIL} in the example). By default, a
decision table is translated to nested \ic{if}s in a separate function. The
figure shows the translation for the common case where a decision table is used in a \ic{return}.
This case is optimized to not use the indirection of an extra function.}
\label{dectab}     
\end{figure} 























