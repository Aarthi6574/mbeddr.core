\section{OS Configuration}

In this section we discuss the development of external DSLs (i.e. new languages
that are not directly related to C). In the chapter we also discuss the
integration of such a language with mbeddr C after the fact. As an example we
use operating system configuration, something that is necessary in many
scenarios, among them the Lego Mindstorms/OSEK case study discussed from the
website:

\ \ \ \ic{http://mbeddr.wordpress.com/further-reading/}

In this case study we have built an implementation of the OIL language used for
configuring the OSEK operating system. Here is an screenshot with an example OIL
file. It configures all kinds of aspects of the OS, including tasks, events,
various flags and the threadng model.

\begin{center} 
  \includegraphics[scale=0.5]{figures/tutorial/oil0.png}
\end{center}



\subsection{A DSL for OS Configuration}

In this example we build a simplified version of such a language. For now,
the operating system configuration DSL essentially defines a set of tasks:


\begin{lstlisting}[morekeywords={OS, Config, task, prio}]
OS Config                           
------------------------------------
                                    
task mainTask prio = 1              
task eventHandler prio = 2          
task emergencyHandler prio = 3      
\end{lstlisting}



\parhead{A New Language} We create a new language \ic{mbeddr.tutorial.osconfig}
using the $New \rightarrow Language$ menu item on the project. Note that this
language does \emph{not} extend any other language. It is completely standaline,
a completely separate DSL developed with MPS -- no relationship to mbeddr.

Unfortunately because of the way MPS handles cross-model generation, you do have
to create a dependency to a language so you can implement an interface (see
next paragraph below) that makes this language play well with the transformation
schedule. So please create an extends dependency on the \ic{com.mbeddr.base}
language.

\parhead{Structure} In the language we create a new concept \ic{OSConfig}. This
is the concept that contains a complete OS configuration and should be useable
as a root node inside models. This is why we set its \ic{instance can be root}
property to \ic{true}. We also implement \ic{IGeneratesCodeForIDE}; this is the
interface that makes this concept play well with mbeddr's cross-model code
generation (mentioned in the previous paragraph):

\begin{lstlisting}[language=mps]
concept OSConfig extends BaseConcept
                 implements IGeneratesCodeForIDE
  instance can be root: true        
\end{lstlisting}

We also create a new concept interface \ic{IOSConfigContents}. We make it extend
from \ic{INamedConcept} to give each instance a name:

\begin{lstlisting}[language=mps]
interface concept IOSConfigContents extends INamedConcept
\end{lstlisting}

We can now go back to the \ic{OSConfig} and add child collection \ic{contents}
of type \ic{IOSConfigContents}:

\begin{lstlisting}[language=mps]
concept OSConfig extends BaseConcept
  instance can be root: true
  children        
    IOSConfigContents contents 0..n
\end{lstlisting}
                                    
Let us now create a concrete concept that represents some kind of configuration
content: the task definition:

\begin{lstlisting}[language=mps]
concept TaskDef extends BaseConcept         
                implements IOSConfigContents
  properties:                               
    prio : integer                            
\end{lstlisting}

\parhead{Editors} The interface gets no editor, of course. For the task
definition we simply define an indent collection with the \ic{task} keyword, the
name and the priority:

\begin{center} 
  \includegraphics[scale=0.5]{figures/tutorial/taskdefEditor.png}
\end{center}

Finally, the editor for the \ic{OSConfig} itself we define a vertical list that
holds the title, a line, a blank line (a constant with a space in it) and the
vertical list of the \ic{contents} child collection.

\begin{center} 
  \includegraphics[scale=0.5]{figures/tutorial/osconfigEditor.png}
\end{center}

\parhead{Text Generator} So far all languages we have developed were extensions
of a base language. The generator then was a transformation back to the base
language. In case of our operating system configuration there is no base
language -- we have to generate text directly.

Text generators are different from the generators we have seen so far; those are
actually model-to-model transformations since they map one MPS tree onto another
one. For text generators we really just write into a text buffer. The language
to do this is relatively simple. However, since we build text generators only
for low-level base languages, this language really is good enough. 

So let's get started with the text generator for \ic{OSConfig}. Open the
structure editor for the \ic{OSConfig} concept and press the little \ic{+} at
the bottom left of the editor window and add a new Textgen conponent. Here is
the code for it:


\begin{lstlisting}[language=mps, morekeywords={text, gen, component,
extension, encoding, append}] 
text gen component for concept OSConfig { 
  extension : (node)->string { 
    "osconfig"; 
  } 
  encoding : utf-8 
 
  (node, context, buffer)->void { 
    append {OSConfig} \n ; 
    append \n ; 
    foreach c in node.contents { 
      append ${c} \n ; 
    } 
  } 
}
\end{lstlisting}

In this texgen component we specify the encoding, the file extension as well as
the contents of the file. The code involving the \ic{append} statements should
be clear. Notice that we did \emph{not} specify the name of the file (only its
extension!). However, our \ic{OSConfig} doesn't have a name. So this won't work!
We have to give a name to \ic{OSConfig}.

To do so, go back to the structure of \ic{OSConfig} and make the concept
implement \ic{INamedConcept}. However, we don't really want to manually enter
the name for each of these things; instead, the name of the \ic{OSConfig} should
automatically be the name of the model in which it resides. You can achieve this
by implementing a getter for the name in the constraints section:


\begin{lstlisting}[language=mps, morekeywords={property, get, is, valid}]
concept constraints OSConfig { 
   
  property {name} 
    get:(node, scope)->string { 
      node.model.name; 
    } 
    set:<default> 
    is valid:<default> 
}
\end{lstlisting}

We also have to implement the textgen for the \ic{TaskDef}. It is really
trivial:

\begin{lstlisting}[language=mps, morekeywords={text, gen, component,
extension, encoding, append}]
text gen component for concept TaskDef { 
  (node, context, buffer)->void { 
    append {task} ${node.name} { } {(} ${node.prio + ""} {}} ; 
  } 
}
\end{lstlisting}

You can now regenerate your model and, next to the C code, you should also get
a \ic{.osconfig} file that contains the operating system configuration.



\subsection{Connecting to C}

The language developed so far is completely independent of mbeddr C (even
though for technical reasons it depends on \ic{com.mbeddr.base} for the
\ic{IGeneratesCodeToIDE} interface). However, we may still want to refer to
concepts defined in that language from C code. 

In our example, we may want to provide a task implementation in C that
corresponds to the task definitions in the OS configuration. In classical C, you
may have to define a function that has the same name as the task and use a
specific signature. Maybe some kind of special modifier is necessary. While we
may generate such code (see below), we want to provide a better programming
experience to the end user. In the code below you can see the new keyword
\ic{task}; it represent a task implementation. The name behind it
(\ic{nameTask}) isn't just a name. Instead it is a reference to a task
definition in an OS config file. Pressing \ic{Ctrl-Space} will code-complete to
all available task definitions.


\begin{lstlisting}[language=mbeddr, morekeywords={task}]
module Tasks imports nothing { 
   
  void aHelperFunction() { } 
   
  task mainTask { 
    // here is some code that implements the task 
    int8 aVariable = 10; 
    aHelperFunction(); 
  }
}
\end{lstlisting}




\parhead{Another New Language} We create a new language
\ic{mbeddr.tutorial.osconfig.cimpl}. It acts as the adapter between mbeddr C and
the OS configuration. To this end it extends these three languages:

\begin{center} 
  \includegraphics[scale=0.5]{figures/tutorial/osconfigcimpl.png}
\end{center}
 

\parhead{Structure} We create a new concept \ic{TaskImpl} that implements
\ic{IModuleContent} so it can be used inside modules. It has a single reference
to a \ic{TaskDef} as well as a \ic{StatementList} for the body:


\begin{lstlisting}[language=mps, morekeywords={implements}]
concept TaskImpl extends BaseConcept      
                 implements IModuleContent
  children:                               
    StatementList body  1
                                          
  references:                             
    TaskDef       task  1      
                                          
  concept properties:                     
    alias = task                            
\end{lstlisting}
                                          
Note that we specify an alias for the concept even though it is technically a
smart reference (it has exactly one reference). However, for this guy we do
\emph{not} want to trigger the special editor behavior. Instead we want the user
to first create a \ic{TaskImpl} node by typing \ic{task} in a module and then
select the reference to the \ic{TaskDef}.

Normally we would have to define a scope for the \ic{task} reference. However,
the default behavior (which puts all the nodes in the current model into the
scope) is exactly what we want so we don't have to do anything.

\parhead{Generator} Let us assume that the compiler for the OS we use in this
example (some kind of fictional OSEK) expects task implementation function to
use a special syntax: the example \ic{mainTask} must be translated as follows:

\begin{lstlisting}[language=mps, morekeywords={implements}]
task(mainTask) void Tasks_taskimpl_mainTask(void) {
  // here is some code that implements the task
  int8_t aVariable = 10;
  Tasks_aHelperFunction();
}
\end{lstlisting}

To create this function we define a generator with a reduction rule that looks
as follows:


\begin{center} 
  \includegraphics[width=\columnwidth]{figures/tutorial/taskimplreduction.png}
\end{center}

The generator uses a property macro to adapt the name, as well as a
\ic{COPY\_SRCL} macro to copy in all the statements of the body. We also add a
special modifier to the function. Modifiers can be added via an intention
(\ic{Alt-Enter}). The \ic{[...]} modifier accepts arbitrary text between the
brackets and then just outputs that text during text generation. We use the
\ic{taskPrefix} dummy text in the template and then replace it with the
following macro expression:

\begin{lstlisting}
"task(" + node.task.name + ")";
\end{lstlisting}



\subsection{Memory Layout}

















