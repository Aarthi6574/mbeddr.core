\chapter{MPS Language Development Primer}

As we have suggested in the intro to this part, we cannot provide a complete MPS
tutorial and instead refer to the general MPS documentation. However, here are
some basics that may help you get started.

\section{The Structure of Programs and Languages}
\label{structureofprograms}


\parhead{Concrete and Abstract Syntax} Programs can be represented in their
abstract syntax and the concrete syntax forms. The \emph{concrete syntax} is the
notation with which the user interacts as he edits a program. It may be textual,
symbolic, tabular, graphical or any combination thereof. The \emph{abstract
syntax} is a data structure that represents the semantically relevant data
expressed by a program (also known as a meta model or the \emph{structure} of a
language). It does not contain notational details such as keywords, symbols,
white space or positions, sizes and coloring in graphical notations.
The abstract syntax is used for analysis and downstream processing of programs.
A language definition includes the concrete and the abstract syntax, as well as
rules for mapping one to the other. \emph{Parser-based} systems map the concrete
syntax to the abstract syntax. Users interact with a stream of characters, and a
parser derives the abstract syntax by using a grammar and mapping rules.
\emph{Projectional} editors like MPS go the other way round: user interactions,
although performed through the concrete syntax, \emph{directly} change the
abstract syntax. The concrete syntax is a mere projection (that looks and feels
like text when a textual projection is used). No parsing takes place.


\begin{figure}[h]
\begin{center}
  \includegraphics[width=4cm]{figures/tutorial/csVsAs.png} 
  \caption{Concrete and abstract syntax for a textual variable declaration.
  Notice how the abstract syntax does not contain the keyword \ic{var} or the
  symbols \ic{:} and \ic{;}.}
  \label{csVsAs} 
\end{center} 
\end{figure}




The abstract syntax of programs are primarily trees of program \emph{elements}
or \emph{nodes} in MPS' terminology. Each element is an instance of a
\emph{language concept}, or \emph{concept} for short. A language is essentially
a set of concepts (we'll come back to this below).
Every element (except the root) is contained by exactly one parent element.

\begin{center}  
\includegraphics[width=35mm]{figures/tutorial/programsAsTrees.png}
\end{center} 

Syntactic nesting of the concrete syntax corresponds to a parent-child
relationship in the abstract syntax. There may also be any number of
non-containing cross-references between elements, established 
during editing in a projectional system.




\parhead{Fragments} A program may be composed from several program
\emph{fragments}. A fragment is a standalone tree, a partial program. In MPS
fragments are known as \emph{Root Nodes}. 

\begin{center}
  \includegraphics[width=35mm]{figures/tutorial/fragment.png} 
\end{center} 





\parhead{Languages} A language $l$ consists a set of language concepts $C_l$ and
their relationships\footnote{In the world of grammars, a
concept is essentially a \emph{Nonterminal}. We will discuss the details about
grammars in the implementation section of this book}. We use the term
\emph{concept} to refer to all aspects of an element of a language, including
concrete syntax, abstract syntax, the associated type system rules and
constraints as well as some definition of its semantics. 

\begin{center}
  \includegraphics[width=4cm]{figures/tutorial/langAsSetOfConcepts.png} 
\end{center} 

In a fragment, each element $e$ is an instance of a concept $c$ defined in some
language $l$. In the example below, the statement \ic{int x = 3;} is an instance
of the \ic{LocalVariableDeclaration} concept. \ic{int} is an instance of
\ic{IntType}, and the \ic{3} is an instance of \ic{NumberLiteral}.

\begin{center}
  \includegraphics[width=8cm]{figures/tutorial/conceptOf.png}
\end{center}



\noindent We define an inheritance relationship that applies the Liskov
Substitution Principle (LSP) to language concepts. The LSP states that, 


\vspace{2mm}
\noindent\emph{In a
computer program, if S is a subtype of T, then objects of type T may be replaced
with objects of type S (i.e., objects of type S may be substitutes for objects
of type T) without altering any of the desirable properties of that program
(correctness, task performed, etc.)} 
\vspace{2mm}

The LSP is well known in the context of
object-oriented programming. In the context of language design it implies that a
concept $c_{sub}$ that extends another concept $c_{super}$ can be used in places
where an instance of $c_{super}$ is expected. 

\begin{center}
  \includegraphics[width=5.5cm]{figures/tutorial/inheritance.png} 
\end{center} 

The \ic{LocalVariableDeclaration} introduced above extends the concept
\ic{Statement}. This way, a local variable declaration can be used wherever a
\ic{Statement} is expected, for example, in the body of a function, which
is a \ic{StatementList}.






\section{Projectional Editing}

In the parser-based approach, a grammar specifies the sequence of tokens
and words that make up a structurally valid program. A parser is generated from
this grammar. A parser is a program that recognizes valid programs in their
textual form and creates an abstract syntax tree or graph. Analysis tools or
generators work with this abstract syntax tree. Users enter programs using the
concrete syntax (i.e.~character sequences) and programs are also stored in this
way. 
\begin{center}
  \includegraphics[width=50mm]{figures/tutorial/parserbased.png}
\end{center}  

Projectional editors (also known as structured editors) work without
grammars and parsers. A language is specified by defining the abstract syntax
tree, then defining projection rules that render the concrete syntax of the
language concepts defined by the abstract syntax. Editing actions \emph{directly}
modify the abstract syntax tree. Projection rules then render a textual (or
other) representation of the program. Users read and write programs through this
projected notation. Programs are stored as abstract syntax trees, usually as
XML. As in parser-based systems, backend tools operate on the abstract syntax
tree. 
 

\begin{center}
  \includegraphics[width=50mm]{figures/tutorial/projectional.png}
\end{center}


Projectional editing is well known from graphical editors; virtually all of them
use this approach. However, projectional editors can also be used for
textual syntax. While in the past projectional text editors have acquired a bad
reputation mostly because of bad usability, as of 2011, the tools have become
good enough, and computers have become fast enough to make this approach
feasible, productive and convenient to use. MPS is a good example of such a
usable tool.


This explicit instantiation of AST objects happens by picking the respective
concept from the code completion menu using a character sequence defined by the
respective concept. If at any given program location two concepts can be
instantiated using \emph{the same character sequence}, then the projection
editor prompts the user to decide\footnote{As discussed above, this is the
situation where many grammar-based systems run into problems from ambiguity.}.
Once a concept is instantiated, it is stored as a node with a unique ID (UID) in
the AST. References between program elements are based on actual pointers
(references to UIDs), and the projected syntax that represents the reference can
be arbitrary. The AST is actually an abstract syntax graph \emph{from the
start} because cross-references are first-class rather than being resolved after
parsing\footnote{There is still one single containment hierarchy, so it is
really a tree with cross-references.} The program is stored using a generic tree
persistence mechanism, often XML.

Defining a projectional editor, instead of defining a grammar, involves the
definition of projection rules that map language concepts to a notation. It also
involves the definition of event handlers that modify the AST based on
users' editing gestures. The way to define the projection rules and the event
handlers is specific to the particular tool used. 

The projectional approach can deal with arbitrary syntactic forms including
traditional text, symbols (as in mathematics), tables or graphics. Since no
grammar is used, grammar classes are not relevant here. In principle,
projectional editing is simpler in principle than parsing, since there is no
need to "extract" the program structure from a flat textual source. However, as
we will see below, the challenge in projectional editing lies making the editing
experience convenient. In particular, editing notations that look like
text should be editable with the editing gestures known from text editors. 
Here are some of the approaches MPS uses to achieve this. For you as the
language developer this is relevant because you have to explicitly define some
of these:

\begin{itemize}

  \item Every language concept that is legal at a given program location is
  available in the code completion menu. In naive implementations, users have to
  select the language concept (based on its name) and instantiate it. This is
  inconvenient. In MPS, languages can instead define aliases for language
  concepts, allowing users to "just type" the alias, after which the concept
  is immediately instantiated\footnote{By making the alias the same as the
  leading keyword (e.g.,~\ic{if} for an \ic{IfStatement}), users can "just
  type" the code.}.

  \item So-called side transforms make sure that expressions can be entered
  conveniently. Consider a local variable declaration \ic{int a = 2;}. If this
  should be changed to \ic{int a = 2+3;} the \ic{2} in the init expression needs
  to be replaced by an instance of the binary \ic{+} operator, with the \ic{2}
  in the left slot and the \ic{3} in the right. Instead of removing the \ic{2}
  and manually inserting a \ic{+}, users can simply type \ic{+} on the right
  side of the \ic{2}; the system performs the tree restructuring that moves the
  \ic{+} to the root of the subtree, puts the \ic{2} in the left slot, and then
  puts the cursor into the right slot, to accept the second argument. This means
  that expressions (or anything else) can be entered linearly, as expected. For
  this to work, operator precedence has to be specified, and the tree has to be
  constructed taking these precedences into account. Precedence is typically
  specified by a number associated with each operator, and whenever using a side
  transformation to build an expression, the tree is automatically reshuffled to
  make sure that those operators with a higher precedence number are further
  down in the tree.
  
  \item Delete actions are used to similar effect when elements are deleted.
  Deleting the \ic{3} in \ic{2+3} first keeps the plus, with an empty right slot.
  Deleting the \ic{+} then removes the \ic{+} and puts the \ic{2} at the root of the subtree.


  \item Wrappers support instantiation of concepts that are actually children of
  the concepts allowed at a given location. Consider again a local variable
  declaration \ic{int a;}. The respective concept could be
  \ic{LocalVariableDeclaration}, a subconcept of \ic{Statement}, to make it
  legal in method bodies (for example). However, users simply want to start
  typing \ic{int}, i.e.\ selecting the content of the \ic{type} field of the
  \ic{LocalVariableDeclaration}. A wrapper can be used to support entering
  \ic{Type}s where \ic{LocalVariableDeclaration}s are expected. Once a \ic{Type}
  is selected, the wrapper implementation creates a
  \ic{LocalVariableDeclaration}, puts the \ic{Type} into its \ic{type} field,
  and moves the cursor into the \ic{name} slot.


  \item Smart references achieve a similar effect for references (as opposed to
  children). Consider pressing \ic{Ctrl-Space} after the \ic{+} in \ic{2+3}.
  Assume further, that a couple of local variables are in scope and that these
  can be used instead of the \ic{3}. These should be available in the code
  completion menu. However, technically, a \ic{VariableReference} has to be
  instantiated, whose \ic{variable} slot then is made to point to any of the
  variables in scope. This is tedious. Smart references trigger special editor
  behavior: if in a given context a \ic{VariableReference} is allowed, the
  editor \emph{first} evaluates its scope to find the possible targets and then
  puts those targets into the code completion menu. If a user selects one,
  \emph{then} the \ic{VariableReference} is created, and the selected element is
  put into its \ic{variable} slot. This makes the reference object effectively
  invisible in the editor.


  \item Smart delimiters are used to simplify inputting list-like data that is
  separated with a specific separator symbol, such as parameter lists. Once a
  parameter is entered, users can press comma, i.e.\ the list delimiter, to
  instantiate the next element.

\end{itemize}


\subsection{Language Aspects}


When defining a language in MPS, you have to define several language aspects.
Some of them are familiar from the disussion above, others haven't been
mentioned yet. In the rest of this part of the user guide we'll provide example
for all of these aspects; here is a general overview:

\parhead{Structure} 




















 
 
 
