\section{Differences to regular C}

This section describes the differences between mbeddr C and regular C99.
All examples shown in this chapter can be found in the \emph{HelloWorld} project
that is available for download together with the \emph{mbeddr.core}
distribution.

\todo{Use noindent consistently} 
 
\subsection{Preprocessor}

mbeddr C does not support the preprocessor. Instead we provide first class
concepts for the various use cases of the C preprocessor. This avoids some of
the chaos that can be created by misusing the preprocessor and provides much
better analyzability. We will provide examples later.

The major consequence of not having a preprocessor is that the separation
between header and implementation file is not exposed to the programmer. mbeddr
provides \ic{modules} instead.


\subsection{Modules}

While we \emph{generate} header files, we don't \emph{expose} them to the user
in MPS. Instead, we have defined modules as the top-level concept. Modules also
act as a kind of namespace. Module contents can be exported, in which case, if a
module is imported by another module, the exported contents can be used by the
importing module.


We distinguish between \emph{implementation modules} which contain actual
implementation code, and \emph{external modules} which act as proxies for
existing, non-mbeddr header files that should be accessible from within mbeddr C
programs.


\paragraph{Implementation Modules} The following example shows an implementation
module (\ic{ImplementationModule}) with an exported function. You can toggle the
\emph{exported} flag with the intention \intention{Toggle Export}. The second
module (\ic{Module- UsingTheExportedFunction}) imports the
\ic{ImplementationModule} with the \ic{im- ports} keyword in the module header.
An importing module can access all exported contents defined in imported modules.


\begin{code}
module ImplementationModule imports nothing { 
   
  exported int32_t add(int32_t i, int32_t j) { 
    return i + j; 
  } 
}

module ModuleUsingTheExportedFunction imports ImplementationModule {

  int32_t main(int8_t argc, string[ ] args) { 
    int32_t result = add(10, 15); 
    return 0; 
  } 
}
\end{code}

	
\paragraph{External modules} mbeddr C code must be able to work with existing
code and existing C libraries. So to call existing functions or instantiate
\ic{struct}s, we use the following approach:


\begin{itemize}
  \item We identify existing external header files and the corresponding object
  or library files.
  \item We create an \emph{external module} to represent those; the external
  module specifies the \ic{.h} file and the object/library files it represents.
  \item In the external module we add the contents of the existing \ic{.h}
  files we want to make accessible to the mbeddr C program.
  \item We can now import the external module into any implementation module
  from which we want to be able to call into the external code
  \item The generator generates the necessary \ic{\#include} statements, and the
  corresponding build configuration.
\end{itemize}


Manually entering the contents of the header file into an external module is
tedious and error-prone. mbeddr comes with an automatic import for external
header files. Since this process is not as trivial as it may seem, we discuss it
extensively in \sect{headerimport}.


\subsection{Build configuration}

The \ic{BuildConfiguration} specifies how a model should be translated and
which modules should be compiled into an executable. Typically it will be
generated into a \ic{make} file that performs the compilation. We have discussed
the basics as part of the Hello World in \sect{buildconfigHelloWorld}. We won't
repeat the basics here.

The main part of the build configuration supports the definition of binaries.
Binaries are either executables or libraries. 

\paragraph{Executables} An executable binds together a set of modules and
compiles them into an executable. Exactly one module in a executable shall have
a main function.

The build configuration, if it uses the \ic{desktop} target, is generated into
a \ic{make} file which is automatically run as part of the MPS build,
resulting in the corresponding executables. The generated code, the \ic{make}
file and the executables can be found in the \ic{source\_gen} folder of the
respective solution (this directory can be changed via the \ic{Generator Output
Path} property in the solution properties).

\greyboxnote{The build language is designed to be extended for integration with
other build infrastructures. In that case, other targets (than \ic{desktop})
would be provided by the language that provides integration with a particular
build infrastructure.}


 
\paragraph{Libraries} Libraries are binaries that are not executable.
Specifically, they are \ic{libXXXX.a} files which can be linked into
executables. A library will typically reside in its own MPS model (and hence in
its own \ic{source\_gen} directory). To create a library, create a build
configuration with a \ic{static library}:

\begin{code}
static library MathLib { 
  MyFirstModule 
  MyOtherModule
}
\end{code}

Running the resulting make file will create a \ic{libMathLib.a}. Using the
library for inclusion in an executable (which \emph{must} be in a different
MPS model!) requires the following three steps:

\begin{itemize}
  \item You have to import the model. Open the properties of the model that
  contains the code that \emph{uses} the library, and add the model that
  \emph{contains} the library to the \ic{Imported Models}.
  This is necessary so that MPS can see the nodes defined in that model.
  
\begin{center} 
  \includegraphics[width=10cm]{figures/core/modelimport.png}
\end{center}

  \item In the implementation module that wants to \emph{use} the functionality defined
  in the library, import the corresponding module(s) from the library. The
  importing module will see all the exported contents in the imported module 
  (this is just like any other inter-module dependency).
  \item finally, in the build configuration of the executable that \emph{uses}
  the library, the used library has to be specified in the \ic{used libraries}
  section:
  
\begin{code}
executable AnExe isTest: true { 
  used libraries 
    MathLib  
  included modules 
    MainModule 
}
\end{code}  
  
\end{itemize}





\subsubsection{Extending the Build Process}

The build configuration is built in a way it is easily extensible. We will
discuss details in the extension guide, but here are a couple of hints:

\begin{itemize}
  \item New configuration items can be contributed by implementing the
  \ic{IConfigu- rationItem} interface. They are expected to be used from
  transformation code. It can find the relevant items by querying the current
  model for a root of type \ic{IConfigurationContainer} and by using the
  \ic{BCHelper} helper class.
  \item New platforms can be contributed by extending the \ic{Platform} concept.
  Users then also have to provide a generator for \ic{BuildConfiguration}s.
\end{itemize} 



\subsection{Unit tests}

Unit Tests are supported as first class citizens by mbeddr C. A \ic{TestCase}
implements \ic{IModuleContent}, so it can be used in implementation modules
alongside with functions, \ic{struct}s or global variables. To assert the
correctness of a result you have to use the \ic{assert} statement followed by a
Boolean expression (note that \ic{assert} can just be used \emph{only} inside
test cases). A \ic{fail} statement is also available --- it fails the test
unconditionally.

\begin{code}
module AddTest imports nothing { 
   
  exported test case testAddInt { 
    assert(0) 1 + 2 == 3; 
    assert(1) -1 + 1 == 1; 
  }  
  
 
  exported test case testAddFloat { 
    float f1 = 5.0; 
    float f2 = 10.5; 
    assert(0) f1 + f2 == 15.5; 
  }  
}
\end{code}


The next piece of code shows a main function that executes the test cases
imported from the \ic{AddTest} module. The \ic{test} expression supports
invocations of test cases; it also evaluates to the number of failed assertions.
By returning this value from \ic{main}, we get an exit code != 0 in the case a
test failed.

\begin{code}
module TestSuite from HelloWorld.UnitTests imports AddTest { 
  int32_t main() { 
    return test testAddInt, testAddFloat; 
  } 
}
\end{code}

For executables that contain tests, in the build configuration, the \ic{isTest}
flag can be set to \ic{true}; this adds a \ic{test} target to the \ic{make} file, so
you can call \ic{make test} on the command line in the \ic{source\_gen} folder
to run the tests.

The example above contains a failing assertion \ic{assert(1) -1 + 1 == 1;}.
Below is the console output after running \ic{make test} in the generated source
folder for the solution:

\begin{code}
runningTest: running test @AddTest:test_testAddInt:0
FAILED: ***FAILED*** @AddTest:test_testAddInt:2
  testID = 1
runningTest: running test @AddTest:test_testAddFloat:0
make: *** [test] Error 1
\end{code}

If you change the assertion to \ic{assert(1) -1 + 1 == 0;}, rebuild with
\keystroke{Ctrl-F9} and rerun \keystroke{make test} you will get the following
output, which has no errors:

\begin{code}
runningTest: running test @AddTest:test_testAddInt:0
runningTest: running test @AddTest:test_testAddFloat:0
\end{code}

 
Test cases can of course call arbitrary functions. However, as we have stated
earlier, \ic{assert} and \ic{fail} statements must reside in test cases, not in
arbitrary functions (this is related to the way the failures are
implicitly counted and returned back from a test case). However, functions can
be marked as a \ic{test helper} using an intention. \ic{assert} and \ic{fail}
can be used within test helper functions. Test helpers must be called \emph{directly}
from test cases!

\begin{code}
exported test case testAddFloat { 
  assert(0) 1 + 2 == 3; 
  moreStuff(10, 20, 30); 
} 

test helper
void moreStuff(int8_t x, int8_t y, int8_t z) { 
  assert(0) x + y == z; 
} 
\end{code}
 

\todo{HERE}

\subsection{Primitive Numeric Datatypes}
\label{PrimitiveNumericDatatypes}

The standard C data types (\ic{int}, \ic{long}, etc.) have different sizes on
different platforms. This makes them non-portable. C99 provides another set of
primitive data types with clearly defined sizes (\ic{int8\_t}, \ic{int16\_t}).
In mbeddr C you \emph{have} to use the C99 types, resulting in more portable
programs. However, to be able to work with existing header files, the system has
to know how the C99 types relate to the standard primitive types. This is the
purpose of the \ic{TypeSizeConfiguration}. It establishes a size-mapping between
the C99 types and the standard primitive types. The \ic{TypeSizeConfiguration}
mentioned above can be added with the \intention{Create default type size
configuration} (see screenshot below) on modules, or by creating one through the
$New$ menu on models. Every model has to contain exactly one type size
configuration. To fill an existing empty type size configuration with the
default values, you can use an intention on the \ic{TypeSizeConfiguration}.

\begin{center} 
  \includegraphics[width=7cm]{figures/core/AddDefaultTSC.png}
\end{center}

\paragraph{Integral Types} The following integral types are not allowed in
implementation modules, and can only be used in external modules for
compatibility: \lcr{char, short, int, long, long long}, as well as their
unsigned counterparts. The following list shows the default mapping of the C99
types:

\begin{itemize}
	\item \lcr{int8\_t} $\rightarrow$ \lcr{char}
	\item \lcr{int16\_t} $\rightarrow$ \lcr{short}
	\item \lcr{int32\_t} $\rightarrow$ \lcr{int}
	\item \lcr{int64\_t} $\rightarrow$ \lcr{long long}
	\item \lcr{uint8\_t} $\rightarrow$ \lcr{unsigned char}
	\item \lcr{uint16\_t} $\rightarrow$ \lcr{unsigned short}
	\item \lcr{uint32\_t} $\rightarrow$ \lcr{unsigned int}
	\item \lcr{uint64\_t} $\rightarrow$ \lcr{unsigned long long}
\end{itemize}

\paragraph{Floating Point Types} The size of floating point types
can alsoi be speficied, e.g. if they differ from the IEEE754 sizes.
\begin{itemize}
	\item \lcr{float} $\rightarrow$ \lcr{32}
	\item \lcr{double} $\rightarrow$ \lcr{64}
	\item \lcr{long double} $\rightarrow$ \lcr{128}
\end{itemize}


The type size configuration also requires the specification of the size of
\ic{size\_t} and pointers.


\subsection{Booleans}

We have introduced a specific \ic{boolean} datatype, including the \ic{true} and
\ic{false} literals. Integers cannot be used interchangably with Boolean values.
We do provide a (red, ugly) cast operator between integers and booleans for
interop with legacy code. The following example shows the usage of the Boolean
data type.

\begin{code}
module BooleanDatatype from HelloWorld.BooleanDatatype imports nothing { 
  exported test case booleanTest { 
    boolean b = false; 
    assert(0) b == false; 
    if ( !b ) { b = true; } if 
    assert(1) b == true; 
    assert(2) int2bool<1> == true;
  }  
}
\end{code}


\subsection{Literals}

mbeddr C supports special literals for hex, octal and binary
numbers. The type of the literal is the smallest possible signed integer type
(\ic{int8\_t}, \ldots, \ic{int64\_t}) that can represent the number.


\begin{code}
module LiteralsApp imports nothing { 
   
  exported test case testLiterals { 
    int32_t intFromHex = hex<aff12>; 
    assert(0) intFromHex == 720658; 
     
    int32_t intFromOct = oct<334477>; 
    assert(1) intFromOct == 112959; 
     
    int32_t intFromBin = bin<100110011>; 
    assert(2) intFromBin == 307; 
  }  
}
\end{code}

All number literals, including decimal literals are signed by default. A suffix
\ic{u} can be added to make them unsigned.

\subsection{Pointers}

C supports two styles of specifying pointer types: \ic{int *pointer2int} and
\ic{int* pointer2int}. In mbeddr C, only the latter is supported: pointer-ness
is a characteristic of a type, not of a variable.



\paragraph{Pointer Arithmetics} For pointer arithmetics you have to use an
explicit type conversion \ic{pointer2int} and \ic{int2pointer}, as illustrated
in the following code. You can also see the usage of pointer dereference
(\ic{*xp}) and assigning an address with \ic{\&}.


\begin{code}
module BasicPointer imports stdlib {  
  
  exported test case testBasicPointer { 
     
    int32_t x = 10; 
    int32_t* xp = &x; 
    assert(0) *xp == 10; 
     
    int32_t[ ] anArray = {4, 5}; 
    int32_t* ap = anArray; 
    assert(1) *ap == 4; 
     
    // pointer arithmetic 
    ap = int2pointer<pointer2int<ap> + 1>; 
    assert(2) *ap == 5; 

  }   
  ...
}
\end{code}


Memory allocation works the same way as in regular C except that you need an
external module to call functions such as \ic{malloc} from \ic{stdlib}. The next
example illustrates how to do this. Note that \ic{size\_t} is a primitive type,
built into mbeddr. It's size is also defined in a \ic{TypeSizeConfiguration}.

\begin{code}
external module stdlib resources header : <stdlib.h> 
{ 
  void* malloc(size_t size); 
  void free(void* pointer); 
}
\end{code}

You have to include the external module \ic{stdlib} in your implementation
module with \ic{imports stdlib}. You can then call \ic{malloc} or \ic{free}:


\begin{code}
module BasicPointer imports stdlib {    
  ...
  exported test case mallocTest { 
    int8_t* mem = ((int8_t*) malloc(sizeof int8_t)); 
    *mem = 10; 
    assert(0) *mem == 10; 
    free(mem); 
  } 
}
\end{code}


\paragraph{Function Pointers} In regular C, you define a function pointer type
like this: \ic{int (*pt2Function) (int, int)}. The first part is the return
type, followed by the name und a comma separated argument type list. The pointer
asterisk is added before the name. This is a rather ugly notation. In mbeddr, we
have introduced the notion of function types and function references. These are
syntactically different from pointers (of course they are mapped to function
pointers in the generated C code). We have also introduced lambdas (i.e.
closures without their own state).


For function types you first define the argument list and then the return type,
separeted by \ic{=>} (a little bit like Scala). Here is an example:
\ic{(int32\_t, int32\_t)=>(int32\_t)} You can enter a fuction type by using the
\ic{funtype} alias,  (see figure below). Function types are types, so they can
be used in function signatures, local variables or \ic{typedef}s, just like any
other type (see example \em{HelloWorld.Pointer.FunctionPointerAsTypes}).

\begin{center} 
  \includegraphics[width=7cm]{figures/core/AddFunctionPointer.png}
\end{center}

Values of type \ic{funtype} are either references to functions or lambdas. In
regular C, you have use the address operator to obtain a function pointer
(\ic{\&function}). In mbeddr C, you use the \ic{:} operator (as in
\ic{:someFunction}) to distinguish function references from regular pointer
stuff. Of course the type and values have to be compatible; for function types
this means that the signature must be the same. The following example shows the
use of function references:


\begin{code}
module FunctionPointer imports nothing { 
   
  int32_t add(int32_t a, int32_t b) { 
    return a + b; 
  } 
 
  int32_t minus(int32_t a, int32_t b) { 
    return a - b; 
  } 
  
  exported test case testFunctionPointer { 
    // function pointer signature 
    (int32_t, int32_t)=>(int32_t) pt2Function; 
     
    // assign "add" 
    pt2Function = :add; 
    assert(0) pt2Function(20, 10) == 30; 
     
    // assign "minus" 
    pt2Function = :minus; 
    assert(1) pt2Function(20, 10) == 10; 
  } 
}
\end{code}



Function types can be used like any other type. This is illustrated in the next
example. The typedef \ic{typedef (int3\_t, int32\_t)=>(int32\_t) as ftype;}
defines a new function type. The type \ic{ftype} is the first parameter in the
\ic{doOperation} function. You can easily call the function
\ic{doOperation(:add, 20, 10)} and put any suitable function reference as the
first parameter.



\begin{code}
module FunctionPointerAsTypes imports nothing { 
   
  typedef (int32_t, int32_t)=>(int32_t) as ftype; 
 
  int32_t add(int32_t a, int32_t b) { 
    return a + b; 
  }  
 
  exported test case testFunctionPointer { 
    // call "add" 
    assert(0) doOperation(:add, 20, 10) == 30; 
  } 
  
  int32_t doOperation(ftype operation, int32_t firstOp, int32_t secondOp) { 
    return operation(firstOp, secondOp); 
  } 
}
\end{code}

Lambdas are also supported. Lambdas are essentially functions without a name.
They are defined as a value and can be assigned to variables or passed to a
function. The syntax for a lambda is \ic{[arg1, arg2,
\ldots|an-expression-using-args]}. The following is an example:

\begin{code}
module Lambdas imports nothing { 
   
  typedef (int32_t, int32_t)=>(int32_t) as ftype; 

  exported test case testFunctionPointer { 
    assert(0) doOperation([a, b|a + b;], 20, 10) == 30; 
  } 
 
  int32_t doOperation(ftype operation, int32_t firstOp, int32_t secondOp) { 
    return operation(firstOp, secondOp); 
  } 
}
\end{code}

		
\subsection{Enumerations}		

The mbeddr C language also provides enumeration support, comparable to to C99.
There is one difference compared to regular C99. In mbeddr C an enumeration is
not an integer type. This means, you can't do any arithmetic operations with
enumerations.

\greyboxnote{We may add a way to cast enums to ints later if it turns out that
"enum arithmetics" are necessary}.
\todo{What is the current state?}

\begin{code}
module EnumerationApp imports nothing { 
   
  enum SEASON { SPRING; SUMMER; AUTUMN; WINTER; } 
 
  exported test case testEnumeration { 
    SEASON season = SPRING; 
    assert(0) season != WINTER; 
    season = WINTER; 
    assert(1) season == WINTER; 
  } 
}
\end{code}


\subsection{Goto}

mbeddr C supports the definition of labels and the \ic{goto} statement. We
discourage its use. However, \ic{goto}s are useful for implementing
code generators for domain-specific abstractions. This is why they are
available.

\subsection{Variables}


Global variables are identical to regular C. Like all other module contents,
they can be \ic{exported}. A local variable declaration can only declare one
variable at a time; otherwise is it is just like in C (so you cannot write
\ic{int a,b;}).



\subsection{Arrays}

Array brackets must show up after the type, not the variable name. The following
example shows the usage of arrays in mbeddr C, incl. multi-dimensional arrays.
Their usage is equivalent to regular C.


\begin{code}
module ArrayApplication imports nothing { 
   
  exported test case arrayTest { 
    int32_t[3] array = {1, 2, 3}; 
     
    assert(0) array[0] == 1; 
     
    int8_t[2][2] array2 = {{1, 2}, {3, 4}}; 
    assert(1) array2[1][1] == 4; 
  }  
}
\end{code}



\subsection{Reporting}

Reporting (or logging) is provided as a special concept. It's designed as a
platform-independent reporting system. With the current generator and the
\ic{desktop} setting in the build configuration, \ic{report} statements are
generated into a \ic{printf}. For other target platforms, other translations
will be supported in the future, for example, by storing the message into some
kind of error memory.

If you want to use reporting in your module, you first have to define a
\ic{message list} in a module. Inside, you can add \ic{MessageDefinition}s with
three different severities: \ic{ERROR} (default), \ic{INFO} and \ic{WARN}. 

Every message definition has a name (acts as an identifier to reference a
message in a report statement), a severity, a string message and any number of
additional arguments. Currently, only integer values and strings are allowed. 

A \ic{report} statement references a message from a message list and supplies
values for all arguments defined by the message. The following example shows an
example (\ic{active} refers to the fact that these messages have not been
disabled; use the corresponding intentions on the messages to enable/disable
each message).

\begin{code}
module Reporting imports nothing { 
   
  message list demo { 
    INFO programStarted() active: Program has just started running 
    ERROR noArgumentPassedIn(int16_t actualArgCount) active: 
        No argument has been passed in, although an arg is expected 
  } 
 
  int32_t main(int8_t argc, string[ ] args) { 
    report(0) demo.programStarted();
    report(1) demo.noArgumentPassedIn(argc) on argc == 0; 
    return 0; 
  } 
}
\end{code}
 
Note how the first report statement outputs the message in all cases. The second
one only outputs the message if a condition is met.

Report statements can be disabled; this removes all the code from the program,
so no overhead is entailed. Intentions on the message definition support
enabling and disabling messages. It is also possible to enable/disable groups of
messages by using intentions on the message list.

\greyboxnote{At this time there is no way of enabling/disabling messages at
runtime. This will be added in the future.}

\subsection{Assembly Code}

At this point we are not able to write inline assembler. We will enable this
feature in the future.


\subsection{Comments}

In mbeddr we distinguish between commenting out code and adding documentation.
The former retains the AST structure of code, but wraps it in a comment. The
latter supports adding prose text to program elements.


\paragraph{Commenting out Code} Code that is commented out retains its syntax
highlighting, but is shaded with a grey background. 

\begin{center} 
  \includegraphics[width=9cm]{figures/core/commenting.jpg}
\end{center}

Code can be commented out by pressing \keystroke{Ctrl-Alt-C} (this is
technically a refactoring, so this feature is also availale from the
refactorings context menu). This also works for lists of elements. Commented out
code can be commented back in by pressing \keystroke{Ctrl-Alt-C} on the comment
itself (the \ic{//}) or the commented element. 

Commenting out code is a bit different than in regular, textual systems because
code that is commented out is still "live": it is still stored as a tree, code
completion still works in it, it may still be shown in $Find References$, and
refactorings may affect the code. We are not sure if this is a desirable feature
and we are looking for your feedback. Of course, the code is not executed. All
commented program elements are removed during code generation.

Not all program elements can be commented out (since special support by the
language is necessary to make something commentable), only concepts that
implement \ic{ICommentable} can be commented. At this time, this is all
statements and module contents.



\paragraph{Documentation} mbeddr supports comments. There are several kinds of
comments that can be used: single line statement comments, multi-line statement
comments and element documentations.

Single line statement comments are comments that can be used in statement
context. For example, in a function body, you can type \ic{//} and fill in
arbitrary text behind. One line only! The following shows as simple comment.

\begin{center} 
  \includegraphics[scale=0.5]{figures/core/onelinecomment.png}
\end{center}

A multi-line comment statement can be created by typing \ic{/*} in statement
context. It supports multiple lines. However, since there is no wrapping over
into the next line, editing can be cumbersome. To solve this problem you can 
press \ic{Ctrl-A} anywhere in the multi-line comment to open a dialog with a
regular text area. You can edit the text in this text area and when you close it
with \ic{OK} the text is transferred back into the actual comment.

\begin{center} 
  \includegraphics[scale=0.35]{figures/core/multilinecomment.png}
\end{center}

You can also press \ic{Ctrl-Y} on a multi-line comment to automatically
rearrange the line contents.

The two statement comments discussed above have two important limitations.
The first one is that they are standalone statements and not connected to any
program element (other than through their position in the code). Second, they
can only be used in statement context. A better solution in many cases is to use
the element documentation. It is semantically attached to a program element. To
create one, either press \ic{Ctrl-A} or use the \ic{Add Documentation}
intention. It looks just like a multi-line comment (and has the same edit
dialog for convenient editing), but it is attached to (and hence moves around
with) a program element. Currently, all statements and module contents can be
annotated with an element documentation.

\paragraph{TODOs} mbeddr comes with a special view for collecting and showing
TODOs in comments. Anywhere within the comments discussed above, you can write
\ic{TODO and then some text} or \ic{TODO(category) and then some text} (see
next screenshot):


\begin{center} 
  \includegraphics[scale=0.35]{figures/core/todoexamplecode.png}
\end{center}

To find the TODOs anywhere in your project, use the $Tools -> mbeddr TODO$. It
shows the TODOs in the form of a Find Usages dialog.

\begin{center} 
  \includegraphics[scale=0.35]{figures/core/todoview.png}
\end{center}

The view has many view options (try them!). The most important one is the top
left one. Pressing it enables categories. In this case the TODOs are grouped by
what has been specified by \ic{category} in the \ic{TODO(category)} format.

















