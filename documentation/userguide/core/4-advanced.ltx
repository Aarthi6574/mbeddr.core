\section{Command Line Generation}

mbeddr C models can be generated to C code from the command line using \ic{ant}.
The \ic{HelloWorld} project comes with an example ant file: in the project
root directory, you can find a \ic{build.xml} ant file:

\begin{lstlisting}[language=mbeddr, morekeywords={}]

<project name="HelloWorld" default="build">

  <property file="build.properties"/>

  <taskdef resource="jetbrains/mps/build/ant/antlib.xml"
           classpath="\${mps.home}/languages/generate.ant.task.jar"/>

  <target name="build">
    <mps.generate loglevel="info" fork="true" failonerror="true">
      <jvmargs id="myargs">
       <arg value="-Xmx512m"/>
      </jvmargs>
      <project file="\${mbeddr.home}/code/applications/HelloWorld/HelloWorld.mpr"/>
      <library name="mbeddr" dir="\${mbeddr.home}/code/languages"/> 
    </mps.generate>
  </target>

</project>  
\end{lstlisting}

It uses the \ic{mps.generate} task provided with MPS. All the code is
boilerplate, except these two lines:

\begin{lstlisting}[language=mbeddr, morekeywords={}]

<project file="\${mbeddr.home}/code/applications/HelloWorld/HelloWorld.mpr"/>
<library name="mbeddr" dir="\${mbeddr.home}/code/languages"/> 
\end{lstlisting}

The first line specifies the project whose contents should be generated. We
point to the \ic{HelloWorld.mpr} project in our case. If you only want to
generate parts of a project (only some solutions or models), take a look at this
article:

\begin{lstlisting}[language=mbeddr, morekeywords={}]

http://confluence.jetbrains.net/display/MPSD2/HowTo+--+MPS+and+ant 
\end{lstlisting}

The second line points to the directory that contains all the languages used by the to-be-generated project. 

To make it work, you also have to provide a \ic{build.properties} file to
define two path variables: 

\begin{lstlisting}[language=mbeddr, morekeywords={}]

mps.home=/some/path/to/MPS2.5/
mbeddr.home=/the/path/to/mbeddr/
\end{lstlisting}

Assuming you have installed \ic{ant}, you can simply type \ic{ant} at the
command prompt in the directory that contains the \ic{build.xml} file.
Unfortunately, generation takes quite some time to execute (50 seconds on my
machine). However, most of the time is startup and loading all the languages, so
having a bigger program won't make much of a difference. The output should look
like this:

\begin{lstlisting}[]

~/Documents/mbeddr/mbeddr.core/code/applications/HelloWorld (master)$ ant 
Buildfile: mbeddr.core/code/applications/HelloWorld/build.xml

init:
   [delete] Deleting directory /Users/markusvoelter/temp/mpscache
    [mkdir] Created dir: /Users/markusvoelter/temp/mpscache

build:
[mps.generate] Loaded project MPS Project [file=.../HelloWorld/HelloWorld.mpr]
[mps.generate] Generating in strict mode, parallel generation = on
[mps.generate] Generating:
[mps.generate]     MPS Project [file=.../HelloWorld/HelloWorld.mpr]

BUILD SUCCESSFUL
Total time: 41 seconds
\end{lstlisting}

You can now run \ic{make} to build the executable. 


\section{Version Control - working with MPS, mbeddr and git}

This section explains how to use git with MPS. It assumes a basic knowledge
of git and the git command line. The section focuses on the integration with
MPS. We will use the git command line for all of those operations that are not
MPS-specific.

We assume the following setup: you work on your local machine with a clone of an
existing git repository. It is connected to one upstream repository by the name
of \ic{origin}.

\subsection{Preliminaries}

\subsubsection{VCS Granularity}

MPS reuses the version control integration from the IDEA platform. Consequently,
the granularity of version control is the file. This is quite natural for
project files and the like, but for MPS models it can be confusing at the
beginning. Keep in mind that each \emph{model}, living in solutions or
languages, is represented as an XML file, so it is these files that are handled
by the version control system.

\subsubsection{The MPS Merge Driver}

MPS comes with a special merge driver for git (as well as for SVN) that makes
sure MPS models are merged correctly. This merge driver has to be configured in
the local git settings. In the MPS version control menu there is an entry
\emph{Install Version Control AddOn}. Make sure you execute this menu entry
before proceeding any further. As a result, your \ic{.gitconfig} should contain
an entry such as this one:

\begin{lstlisting}[language=mbeddr, morekeywords={}]

[merge "mps"]
	name = MPS merge driver
	driver = "\"/Users/markus/.MPS25/config/mps-merger.sh\" %O %A %B %L"
\end{lstlisting}


\subsubsection{The .gitignore}

For all projects, the \ic{.iws} file should be added to \ic{.gitignore}, since
this contains the local configuration of your project and should not be shared
with others.

Regarding the (temporary Java source) files generated by MPS, two approaches are
possible: they can be checked in or not. Not checking them in means that some of
the version control operations get simpler because there is less "stuff" to deal
with. Checking them in has the advantage that no complete rebuild of these files
is necessary after updating your code from the VCS, so this results in a
faster workflow. 

If you decide \emph{not} to check in temporary Java source files, the following
directories and files should be added to the \ic{.gitignore} in your local
repo:

\begin{itemize}
  \item For languages: \ic{source\_gen}, \ic{source\_gen.caches} and 
  \ic{classes\_gen}
  \item For solutions, if those are Java/BaseLanguage solutions, then the same
  applies as for languages. If these are other solutions to which the
  MPS-integrated Java build does not apply, then \ic{source\_gen} and
  \ic{source\_gen.caches} should be added, plus whatever else your own build
  process creates in terms of temporary files.
\end{itemize}

Make sure the \ic{.history} files are \emph{not} added to the \ic{gitignore}!
These are important for MPS-internal refactorings.

\subsubsection{MPS' caches and Branching}

MPS keeps all kinds of project-related data in various caches. These caches are
outside the project directory and are hence not checked into the VCS. This is
good. But it has one problem: If you change the branch, your source files
change, while the caches are still in the \emph{old} state. This leads to all
kinds of problems. So, as a rule, whenever you change a branch (that is not
just trivially different from the one you have used so far), make sure you
select \ic{File -> Invalidate Caches}, restart and rebuild your project.

Depending on the degree of change, this may also be advisable after pulling from
the remote repository.





\subsection{Committing Your Work}

In git you can always commit locally. Typically, commits will happen quite
often, on a fine grained level. I like to do these from within MPS. The
screenshot below shows a program where I have just added a new variable. This is
highlighted with the green bar in the gutter. Right-Clicking on the green bar allows you to rever
this change to the latest checked in state.

\begin{center} 
  \includegraphics[width=9cm]{figures/core/green.jpg}
\end{center}


In addition you can use the \ic{Changes} view (from the \ic{Window -> Tool
Windows} menu) to look at the set of changed files. In my case
(\fig{changesview}) it is basically one \ic{.mps} file (plus two files realted
to writing this document :-)). This \ic{.mps} file contains the test case to
which I have added the new variable.

\begin{center} 
  \includegraphics[width=12cm]{figures/core/changesview.jpg}
\end{center}

To commit your work, you can now select \ic{Version Control -> Commit Changes}.
The resulting dialog, again, shows you all the changes you have made and you can
choose which one to include in your commit. After committing, your \ic{git
status} will look something like this and you are ready to push:

\begin{lstlisting}[language=mbeddr, morekeywords={}]

Markus-Voelters-MacBook:lwes-assembla markus$ git status
# On branch demo
# Your branch is ahead of 'assembla/demo' by 1 commit.
#
nothing to commit (working directory clean)
Markus-Voelters-MacBook-Air:lwes-assembla markus$ 
\end{lstlisting}

\subsection{Pulling and Merging}

Pulling (or merging) from a remote repository or another branch is when you
potentially get merge conflicts. I usually perform all these operations from the
command line. If you run into merge conflicts, they should be resolved from
within MPS. After the pull or merge, the \ic{Changes} view will highlight
conflicting files in red. You can right-click onto it and select the \ic{Git
-> Merge Tool} option. This will bring up a merge tool on the level of the
projectional editor to resolve the conflict. Please take a look at the
screencast at \\ 
\hspace*{10mm} \ic{http://www.youtube.com/watch?v=gc9oCAnUx7I} 
\\ to see this process in action. 

The process described above and in the video works well for MPS model files.
However, you may also get conflicts in project, language or solution files.
These are XML files, but cannot be edited with the projectional editor. Also,
if one of these files has conflicts and contains the \ic{< < < <} and
\ic{> > > >} merge markers, then MPS cannot open these files anymore because
the XML parser stumbles over these merge markers.

I have found the following two approaches to work:

\begin{itemize}
  \item You can either perform merges or pulls while the project is closed
  in MPS. Conflicts in project, language and solution files should then be 
  resolved with an external merge tool such as \emph{WinMerge} before attempting
  to open the project again in MPS.
  \item Alternatively you can merge or pull while the project is open (so the
  XML files are already parsed). You can then identify those conflicing files
  via the \ic{Changes} view and merge them on XML-level with the MPS merge
  tool. After merging a project file, MPS prompts you that the file has been
  changed on disk and suggests to reload it. You should do this.
\end{itemize}

Please also keep in mind my remark about invalidating caches above.

\subsection{A personal Process with git}

Many people have described their way of working with git regarding branching,
rebasing and merging. In principle each of these will work with MPS, when taking
account what has been discussed above. Here is the process I use.

To develop a feature, I create a feature branch with 

\begin{lstlisting}[language=mbeddr, morekeywords={}]
git branch newFeature
git checkout newFeature
\end{lstlisting}

I then immediately push this new branch to the remote repository as a backup,
and to allow other people to contribute to the branch. I use

\begin{lstlisting}[language=mbeddr, morekeywords={}]
git push -u origin newFeature
\end{lstlisting}

Using the \ic{-u} parameter sets up the branch for remote tracking.

I then work locally on the branch, committing changes in a fine-grained way.
I regularly push the branch to the remote repo. In less regular intervals I pull
in the changes from the master branch to make sure I don't diverge too far from
what happens on the master. I use merge for this:

\begin{lstlisting}[language=mbeddr, morekeywords={}]
git checkout master
git pull                   // this makes sure the master is current
git checkout myFeature
git merge master    
\end{lstlisting}

Alternatively you can also use

\begin{lstlisting}[language=mbeddr, morekeywords={}]
git fetch
git checkout myFeature
git merge origin/master    
\end{lstlisting}


This is the time when conflicts occur and have to be handled. In repeat this
process until my feature is finished. I then merge my changes back on the
master:

\begin{lstlisting}[language=mbeddr, morekeywords={}]

git checkout master
git pull                   // this makes sure the master is current
git merge --squash myFeature    
\end{lstlisting}

Notice the \ic{--squash} option. This allows me to "package" all of the commits
that I have created on my local branch into a single commit with a meaningful
comment such as "initial version of myFeature finished".





\section{The Graph Viewer}

mbeddr ships with a graph viewer embedded into MPS. It can be used to visualize
graphviz files. The graph viewer allows to render all graphviz files in the
current solution. It simply scans the \ic{source\_gen} directory recursively for
\ic{.gv} files and shows them in the tree. Underscores in the file name are used
as hierarchies in the tree. Users can create their own transformation to
graphviz graphs, and they will be shown in the tree. A special \ic{graph}
language is available for this transformation (explained in
\sect{generatinggraphs}).

By default, each build configuration results in a diagram that shows the
dependencies between the modules. To see it in the graph viewer, 

\begin{itemize}
  \item Open an implementation module in the editor
  \vspace{-4mm}
  \item select $Tools -> Open Graph Viewer$ from the menu
  \vspace{-4mm}
  \item in the graph viewer, click through the tree until you find a leaf node
  representing a diagram
\end{itemize}

The diagram should open in the lower pane of the graph viewer. You can zoom
(mouse wheel) and move around (press mouse button and move). More interestingly,
you can also click on a node, and the MPS editor selects the respective node. 



