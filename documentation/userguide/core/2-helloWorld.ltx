\section{Hello World Example}

For this tutorial we assume that you know how to use the C programming language.
We also assume that you have have installed MPS, gcc/make, graphviz and the
mbeddr.core distribution. This has been disussed in the previous section. 

\subsection{Create new project}

Start up MPS and create a new project. Call the project \lcr{HelloWorld} and
store it in a directory without blanks in the path. Let the wizard create a
solution, but no language.
 
\begin{center} 
  \includegraphics[width=12cm]{figures/core/NewProject.png}
\end{center}

We now have to make the project aware of the \emph{mbeddr.core} languages
installed via the distribution. Go to the $File \rightarrow Settings$ and select
the $Global Libraries$ in the IDE settings. Create a library called
\ic{mbeddr.core} that points to the root directory of the unzipped mbeddr
installation.

\textbf{Note: This library must point to the root directory of the checkout so
that all languages are below it, including \emph{core} and \emph{mpsutil}.}

\begin{center} 
  \includegraphics[width=10cm]{figures/core/SettingsGlobalLibraries.png}
\end{center}

Notice that this is a settings and have to be performed only once
before your first application project.


\subsection{Project Structure and Settings}

An MPS project is a collection of solutions\footnote{A project can also contain
\emph{languages}, but these are only relevant to language implementors. We
discuss this aspect of mbeddr in the \emph{Extension Guide}}. A \emph{solution}
is an application project that \emph{uses} existing languages. Solutions contain
any number of models; models contain root nodes. Physically, models are XML
files that store MPS programs. They are the relevant version control unit, and
the fundamental unit of configuration.


\begin{center} 
  \includegraphics[width=8cm]{figures/core/workspacecontents.png}
\end{center}

In the solution, create a new model with the name \ic{main}, prefixed with the
solution's name: select $New \rightarrow Model$ from the solution's context
menu. No sterotype.

 

A model has to be configured with the languages that should be used to write the
program in the model. In our case we need all the \ic{mbeddr.core} languages. We
have provided a \emph{devkit} for these languages. A devkit is essentially a set
of languages, used to simplify the import settings. As you create the model, the
model properties dialog should open automatically. In the \emph{Used Devkits}
section, select the \ic{+} button and add the \ic{com.mbeddr.core} devkit.



\begin{center} 
  \includegraphics[width=10cm]{figures/core/AddDependencies.png}
\end{center}


This concludes the configuration and setup of your project. You can now start
writing C code.


\subsection{Create an empty Module}

The top level concept in mbeddr C programs are \emph{modules}. Modules act as
namespaces and as the unit of encapsulation.  So the first step is to create an
empty module. The mbeddr.core C language does not use the artificial separation
between \ic{.h} and \ic{.c} files you know it from classical C. Instead
mbeddr C uses the aforementioned module concept. During code generation we then
create the corresponding \ic{.h} and \ic{.c} files.

A module can import other modules. The importing module can then
access the \emph{exported} contents of imported modules. 

So to get started, we create a new \ic{implementation module} using the model's
context menu as shown in the following screenshot:
\begin{center} 
  \includegraphics[width=12cm]{figures/core/ContextMenuNewModule.png}
\end{center}


\greyboxnote{This operation, as well as almost all others, can be performed with
the keyboard as well. Take a look at $File \rightarrow Settings
\rightharpoondown Keymap$ to find out or change keyboard mappings.}


As a result, you will get an empty implementation module. It currently has
no name (the name is red and underlined) and only a placeholder \ic{<<...>>}
where top level C constructs such as functions, \ic{struct}s, or \ic{enum}s can
be added later.


\begin{center} 
  \includegraphics[width=9cm]{figures/core/EmptyModule.png}
\end{center}



\noindent Next, specify \ic{HelloWorld} as the name for the implementation
module.

\begin{code}
module HelloWorld from HelloWorld.main imports nothing {                                
  << ... >>                      
} 
\end{code}

The module name is still underlined in red because of a missing type size
configuration. The \ic{TypeSizeConfiguration} specifies the sizes of the
primitive types (such as \ic{int} or \ic{long}) for the particular target
platform. mbeddr C provides a \emph{default} type size configuration, which can
be added to a module via an intention \intention{Create default type size
configuration} on the module in the editor. To invoke intentions please use
\keystroke{Alt-Enter}.
You may have to press \keystroke{F5} to make the red underline go away. For more
details on type size configurations see chapter \ref{PrimitiveNumericDatatypes}.
\begin{center} 
  \includegraphics[width=8cm]{figures/core/AddDefaultTSC.png}
\end{center}





\subsection{Writing the Program}			

Within the module you can now add contents such as functions, \ic{struct}s or global
variables. Let's enter a \ic{main} function so we can run the program later. You can
enter a \ic{main} function in one of the the following ways:
\begin{itemize}
	\item create a new function instance by typing \keystroke{function} at the
	placeholder in the module, and then specify the name and arguments. 
	\item simply start typing the return type of the function e.g. \ic{int32\_t}
	\\in this case, and then entering the name.
	\item specifically for the main function, you can also just type
	\keystroke{main} 
	\\(it will set up the correct signature automatically)
\end{itemize} 


At this point, we are ready to implement the Hello World program. Our aim is to
simply output a log message and return \ic{0}. To add a return value, move the
cursor into the function body and type \keystroke{return 0}.


\begin{code}
module HelloWorld from HelloWorld.main imports nothing {                                            
  int32_t main() { 
    return 0; 
  } 
}
\end{code}

To print the message we could use \ic{printf} or some other \ic{stdio} function.
However, in embedded systems there is often no \ic{printf} or the target
platform has no display available, so we use a special language extension for
logging. It will be translated in a suitable way, depending on the available
facilities on the target platform. Also, specific log messages can be
deactivated in which case they are completely removed from the program. Below
our main function we create a new \ic{message list} (just type
\keystroke{message} followed by return) and give it the name \ic{log}.


Within the message list, hit \keystroke{return} or type \keystroke{message} to
create a new message. Change the type from \ic{ERROR} to \ic{INFO} with the help
of code completion. Specify the name \ic{hello}. Add a message property by 
hitting \keystroke{return} between the parentheses. The type should be a
\ic{string} and the name should be \ic{who}. Specify \ic{Hello} as the value
of the \ic{message text} property. The resulting message should look like this:

\begin{code}
  message list log { 
    INFO hello(string who) active: Hello 
  } 
\end{code}

Now you are ready to use the message list and its messages from your
main function. Insert a \ic{report()} statement in the main function, specify
the message list \ic{log} and select the message \ic{hello}. Pass the string
\ic{"World"} as parameter.

\begin{code}
module HelloWorld from HelloWorld.main imports nothing { 
   
  int32_t main(int8_t argc, string[ ] args) { 
    report(0) log.hello("World") on/if; 
    return 0; 
  } main (function) 
  
 
  message list log { 
    INFO hello(string who) active: Hello 
  } 
}
\end{code}



\begin{figure}
	\vspace{0.2cm}
	\rule{\textwidth}{0.7pt}
	\begin{center} 
	  \includegraphics[width=12cm]{figures/core/AddBuildConfiguration.png}
	\end{center}
	\vspace{-0.3cm}
	\rule{\textwidth}{0.7pt}
	\caption{Add a BuildConfiguration Model}
	\label{addBuildConfiguraitonModel}  
\end{figure}


\subsection{Build Configuration}	
\label{buildconfigHelloWorld}		

We have to create one additional element, the \ic{BuildConfiguration}. This
specifies which modules should be compiled into an executable or library, as
well as other aspects related to creating an executable. Depending on the
selected target platform, a \ic{BuildConfiguration} will automatically generate
a corresponding \ic{make} file. In the main model, create a new instance of
\lcr{BuildConfiguration} (via the model's context menu, see
\fig{addBuildConfiguraitonModel}). Initially, it will look as follows:


\begin{code}
Target Platform: 
  <no target> 
 
Configuration Items 
  << ... >> 
 
Binaries 
  << ... >>
\end{code}

You will have to specify three aspects. First you have to select the target
platform. For our tests, we use the \ic{desktop} platform that generates a
\ic{make} file that can be compiled with the normal \ic{gcc} compiler. Other
target platforms may generate build scripts for other build systems. The
\ic{desktop} target contains some useful defaults, e.g. the \ic{gcc}
compiler and its options. 

\begin{code}
Target Platform: 
  desktop 
    compiler: gcc 
    compiler options: -std=c99 
    debug options: <no debug options>
\end{code}

Next, we have to address the configuration items. These are additional
configuration data that define how various program elements are translated. In
our case we have to specify the reporting configuration. Select the placeholder
and type \keystroke{reporting}. It determines how log messages are output. The
\ic{printf} strategy simply prints them to the console, which is fine for our
purposes here.

\begin{code}
Configuration Items 
  reporting: printf 
\end{code}

Finally, in the \ic{Binaries} section, we create a new \lcr{exectuable} and
call it \lcr{HelloWorld}. In the program's body, add a reference to the \lcr{HelloWorld}
implementation module we've created before. The code should look like this:

\begin{code}
executable main isTest: false { 
  used libraries 
    << ... >> 
  included modules 
    HelloWorld 
}
\end{code}
 


\subsection{Building and Executing the Program}

Press \keystroke{Ctrl-F9} (or \keystroke{Cmd-F9} on the Mac) to rebuild the
solution. In the
\\ \ic{HelloWorld/solutions/HelloWorld/source\_gen/HelloWorld/main} directory
you should now have at least the following files (there may be others, but
those are not important now):


\begin{code}
Makefile
HelloWorld.c
HelloWorld.h
\end{code}

The files should be already compiled as part of the mbeddr C build facet (i.e.
\ic{make} is run by MPS automatically). Alternatively, to compile the files
manually, open a command prompt (must be a cygwin prompt on Windows!) in this
directory and type \keystroke{make}. The output should look like the following:


\begin{code}
\$ make
rm -rf ./bin
mkdir -p ./bin
gcc -c -o bin/HelloWorld.o HelloWorld.c -std=c99
\end{code}

This builds the executable file \ic{HelloWorld.exe} or \ic{HelloWorld} (depending on your
platform), and running it should show the following output:

\begin{code}
\$ ./HelloWorld.exe
hello: Hello @HelloWorld:main:0
  world = World
\end{code}

Note the output of the log statement in the program (report statement number
\ic{0} in function \ic{main} in module \ic{HelloWorld}; take a look back at the
source code: the index of the statement (here: \ic{0}) is also output in the
program source). 


\subsection{The Graph Viewer}

The graph viewer allows to render all graphviz files in the current solution. It
simply scans the \ic{source\_gen} directory recursively for \ic{.gv} files and
shows them in the tree. Underscores in the file name are used as hierarchies in
the tree. Users can create their own transformation to graphviz graphs, and they
will be shown in the tree. A special \ic{graph} language is available for this
transformation (will be explained later).

By default, each build configuration results in a diagram that shows the
dependencies between the modules. To see it in the graph viewer, 

\begin{itemize}
  \item Open an implementation module in the editor
  \item select $Tools -> Open Graph Viewer$ from the menu
  \item in the graph viewer, click through the tree until you find a leaf node
  representing a diagram
\end{itemize}

The diagram should open in the lower pane of the graph viewer. You can zoom
(mouse wheel) and move around (press mouse button and move). More interestingly,
you can also click on a node, and the MPS editor selects the respective node. 


\vspace{10mm}
\noindent This concludes our hello world example. In the next section we will
examine important differences between mbeddr C and regular C. 
