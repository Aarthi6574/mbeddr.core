\section{Components}

Let us now introduce components to further structure the system. We start by
factoring the \ic{Trackpoint} data structure into a separate module and export
it to make it accessible from importing modules.


\begin{lstlisting}[language=mbeddr]
module DataStructures imports nothing { 
  exported struct Trackpoint { 
    int8 id; 
    int8/s/ timestamp; 
    int8/m/ x; 
    int8/m/ y; 
    int8/m/ alt; 
    int8/mps/ speed; 
  }; 
}
\end{lstlisting}

\subsection{An Interface with Contracts}

We now define an interface that handles \ic{Trackpoint}s. To be able to do that
we have to add the \ic{com.mbeddr.components} devkit to the current model. We
can then enter a client-server interface in a new module \ic{Components}. We
use pointers for the trackpoints here to optimize performance. Note that you
can just press \ic{*} on the right side of \ic{Trackpoint} to make it a
\ic{Trackpoint*}:

\begin{lstlisting}[language=mbeddr]
module Components imports DataStructures { 
   
  exported c/s interface TrackpointProcessor { 
    Trackpoint* process(Trackpoint* p); 
  } 
   
}
\end{lstlisting}

To enhance the semantic "richness" of the interface we can add preconditions. To
do so, use an intention \ic{Add Precondition} on the operation itself. Please
add the following pre- and postconditions (note how you can of course use units
in the precondition):

\begin{lstlisting}[language=mbeddr]
Trackpoint* process(Trackpoint* p) 
  pre(0) p != null 
  pre(1) p->id != 0 
  pre(2) p->timestamp != 0 s 
  post(3) result->id != 0
\end{lstlisting}

After you have added these contracts, you will get an error message on the
interface. The problem is this: if a contract (pre- or postcondition) fails, the
system will report a message (this message can be deactivated in case you don't
want any reporting). However, for the program to work you have to specify a
message on the interface. We create a new message list and a messge:

\begin{lstlisting}[language=mbeddr]
message list ContractMessages { 
  ERROR contractFailed() active: contract failed 
}
\end{lstlisting}

You can now open the inspector for the interface and reference this message
from there:

\begin{center} 
  \includegraphics[width=0.5\columnwidth]{figures/tutorial/contractmessage.png}
\end{center}

There are still errors. The first one complains that the message list must be
exported if the interface is exported. We fix it by exporting the message list
(via an intention). The next error complains that the message needs to have to
integer arguments to represent the operation and the pre- or postcondition. We
change it thusly:

\begin{lstlisting}[language=mbeddr]
exported message list ContractMessages { 
  ERROR contractFailed(int8 op, int8 pc) active: contract failed
}
\end{lstlisting}


\subsection{A First Component}

Let us create a new component by typing \ic{component}. We call it \ic{Nuller}.
It has one provided port called \ic{processor} that provides the
\ic{TrackpointProcessor} interface:

\begin{lstlisting}[language=mbeddr]
exported component Nuller extends nothing { 
  provides TrackpointProcessor processor 
}
\end{lstlisting}

We get an error that complains that the component needs to implement the
operations defined by the \ic{TrackpointProcessor} interface; we can get those
automatically generated by using a quick fix on the provided port. This gets us
the following:

\begin{lstlisting}[language=mbeddr]
exported component Nuller extends nothing { 
  provides TrackpointProcessor processor 
  Trackpoint* processor_process(Trackpoint* p) <- op processor.process { 
    return null; 
  } 
}
\end{lstlisting}

The \ic{processor\_process} runnable is triggered by an incoming invocation of
the \ic{process} operation defined in the \ic{TrackpointProcessor} interface.
The \ic{Nuller} simply sets the altitute to zero:

\begin{lstlisting}[language=mbeddr]
Trackpoint* processor_process(Trackpoint* p) <- op processor.process { 
  p->alt = 0 m; 
  return p; 
}
\end{lstlisting}

Let us now write a simple test case to check this component. To do that, we
first have to create an instance of \ic{Nuller}. We create an instance
configuration that has an instance of this component. Also, we add an adapter.
An adapter makes a provided port of a component instance
(\ic{Nuller.processor}) available to a regular C program under the specified
name \ic{n}:

\begin{lstlisting}[language=mbeddr]
instances instances extends nothing { 
  instance Nuller nuller
  adapt n -> nuller.processor 
}
\end{lstlisting}

Now we can write a test case that accesses the \ic{n} adapter --- and through
it, the \ic{processor} port of the \ic{Nuller} component instance \ic{nuller}.
We create a new \ic{Trackpoint}, using 0 as the \ic{id} --- intended to trigger
a contract violation (remember \ic{pre(1) p->id != 0}). To enter the \ic{\&tp}
just enter a \ic{\&}, followed by \ic{tp}:

\begin{lstlisting}[language=mbeddr]
exported test case testNuller { 
  Trackpoint tp = { 
    id = 0 
  }; 
  n.process(&tp); 
}
\end{lstlisting}

Before we can run this, we have to make sure that the \ic{instances} are
initialized (cf. the warning you get on them). We do this right in the test
case:

\begin{lstlisting}[language=mbeddr]
exported test case testNuller { 
  initialize instances; 
  Trackpoint tp = { 
    id = 0 
  }; 
  n.process(&tp); 
}
\end{lstlisting}

To make the system work, you have to import the \ic{Components} module into
the \ic{Main} module so you can call the \ic{testNuller} test case from the
\ic{test} expression in \ic{Main}. In the build configuration, you
have to add the missing modules to the executable (using the quick fix).
Finally, also in the build configuration, you have to add the \ic{components}
configuration item:

\begin{lstlisting}[language=mbeddr]
Configuration Items:
  reporting: printf (add labels false) 
  physical units (config = Units Declarations (mbeddr.tutorial.main.m1)) 
  components: no middleware         
              wire statically: false
\end{lstlisting}

You can now rebuild and run. As a result, you'll get contract failures:

\begin{lstlisting}
./MbeddrTutorial
$$runningTest: running test () @FunctionPointers:test_testProcessing:0#767515563077315487
$$runningTest: running test () @Components:test_testNuller:0#767515563077315487
$$contractFailed: contract failed (op=0, pc=1) @Components:null:-1#1731059994647588232
$$contractFailed: contract failed (op=0, pc=2) @Components:null:-1#1731059994647588253
\end{lstlisting}

We can fix these problems by changing the test data to conform to the contract:

\begin{lstlisting}
Trackpoint tp = { 
  id = 10 
  timestamp = 10 s 
  alt = 100 m 
}; 
n.process(&tp); 
assert(0) tp.alt == 0 m;
\end{lstlisting}

Let us provoke another contract violation by returning from the implementation
in the \ic{Nuller} component a \ic{Trackpoint} whose \ic{id} is 0:

\begin{lstlisting}
Trackpoint* processor_process(Trackpoint* p) <- op processor.process { 
  p->alt = 0 m; 
  p->id = 0; 
  return p; 
}
\end{lstlisting}

Running it again provokes another contract failure. Notice how the contract is
specified on the \emph{interface}, but they are checked for each
\emph{component} implementing the interface. There is no way how an
implementation can violate the interface contract without the respective error
being reported!





















































