\section{Decision Tables}

Let us implement another interface, one that lets us judge flights (we do this
in a new section in the \ic{Components} module). The idea is that clients
add trackpoints, and the \ic{FlightJudger} computes some kind of score from it
(consider some kind of biking/flying competition as a context):

\begin{lstlisting}[language=mbeddr]
exported cs interface FlightJudger { 
  void reset() 
  void addTrackpoint(Trackpoint* tp) 
  int16 getResult() 
}
\end{lstlisting}

Here is the basic implementation of a component that provides this interface.

\begin{lstlisting}[language=mbeddr]
exported component Judge extends nothing { 
  provides FlightJudger judger 
  int16 points = 0; 
  void judger_reset() <- op judger.reset { 
    points = 0; 
  }  
  void judger_addTrackpoint(Trackpoint* tp) <- op judger.addTrackpoint { 
    points += 0; // to be changed
  }  
  int16 judger_getResult() <- op judger.getResult { 
    return points; 
  }  
}
\end{lstlisting}

Of course the implementation of \ic{addTrackpoint} that just adds \ic{0} to the
\ic{points} doesn't make much sense yet. The amount of points added should
depend on how fast and how high the plane (or whatever) was going. The following
screenshot shows an embedded decision table that computes points (Notice we mix
the components language, the decision tables and the units in one integrated
program):

\begin{center} 
  \includegraphics[width=0.8\columnwidth]{figures/tutorial/dectab.png}
\end{center}

Let us write a test. Of course we first need an instance of \ic{Judge}:

\begin{lstlisting}[language=mbeddr]
instances instancesJudging extends nothing { 
  instance Judge j 
  adapt j -> j.judger 
}
\end{lstlisting}

Below is the test case. It contains two things you maybe haven't seen before.
There is a second form of the \ic{for} statement that iterates over a range of
values. The range can be exclusive the ends or inclusive (to be changed via an
intention). In the example we iterate from 0 to 4, since 5 is excluded. The
\ic{introduceunit} construct can be used to "sneak in" a unit into a regular
value. This is useful for interacting with non-unit-aware (library) code. Note
how the expression for \ic{speed} is a way of expressing the same thing without
the \ic{introduceunit} in this case. Any expression can be
surrounded by \ic{introduceunit} via an intention.

\begin{lstlisting}[language=mbeddr]
exported test case testJudging { 
  initialize instancesJudging; 
  j.reset(); 
  Trackpoint[5] points; 
  for (i in [0..5[) { 
    points[i].id = i; 
    points[i].alt = introduceunit[1800 + 100 * i -> m]; 
    points[i].speed = 130 mps + 10 mps * i;
    j.addTrackpoint(&points[i]); 
  }  
  assert(0) j.getResult() == 0 + 0 + 20 + 20 + 20; 
} 
\end{lstlisting}






















