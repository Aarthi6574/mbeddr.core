package com.mbeddr.core.debug.test.runtime.m1;

/*Generated by MPS */

import com.google.inject.Singleton;
import com.mbeddr.core.debug.debugger.IMIBreakpointRegistry;
import com.mbeddr.core.debug.debugger.IMIMpsBreakpointListener;
import java.util.List;
import com.mbeddr.core.debug.debugger.IMIBreakpointListener;
import com.intellij.openapi.project.Project;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import com.mbeddr.core.debug.debugger.DebuggerException;
import com.mbeddr.core.debug.debugger.AbstractMIBreakpoint;

@Singleton
public class TRBreakpointRegistryImpl implements ITRBreakpointRegistry, IMIBreakpointRegistry, IMIMpsBreakpointListener {
  private List<ITRBreakpoint> breakpoints;
  private List<IMIBreakpointListener> breakpointListeners;
  private Project project;

  public TRBreakpointRegistryImpl() {
    breakpoints = ListSequence.fromList(new ArrayList<ITRBreakpoint>());
  }

  public ITRBreakpoint add(ITRBreakpointLocation breakpointLocation) throws TRExecutingDebugCommandFailedException {
    TRBreakpointImpl breakpoint = new TRBreakpointImpl(breakpointLocation.getBreakpointable(), project, breakpointLocation.getName());
    try {
      for (IMIBreakpointListener breakpointListener : ListSequence.fromList(breakpointListeners)) {
        breakpointListener.breakpointAdded(breakpoint);
      }
    } catch (DebuggerException e) {
      throw new TRExecutingDebugCommandFailedException("Could not create breakpoint: " + e.getMessage());
    }
    ListSequence.fromList(breakpoints).addElement(breakpoint);
    return breakpoint;
  }

  public void remove(ITRBreakpoint breakpoint) throws IllegalArgumentException, TRExecutingDebugCommandFailedException {
    if (!(ListSequence.fromList(breakpoints).contains(breakpoint))) {
      throw new IllegalArgumentException();
    }
    try {
      for (IMIBreakpointListener breakpointListener : ListSequence.fromList(breakpointListeners)) {
        breakpointListener.breakpointRemoved((AbstractMIBreakpoint) breakpoint);
      }
    } catch (DebuggerException e) {
      throw new TRExecutingDebugCommandFailedException("Could not remove breakpoint: " + e.getMessage());
    }
    ListSequence.fromList(breakpoints).removeElement(breakpoint);
  }

  public List<ITRBreakpoint> getActiveBreakpoints() {
    List<ITRBreakpoint> result = ListSequence.fromList(new ArrayList<ITRBreakpoint>());
    ListSequence.fromList(result).addSequence(ListSequence.fromList(breakpoints));
    return result;
  }

  public List<AbstractMIBreakpoint> getBreakpoints() {
    List<AbstractMIBreakpoint> result = ListSequence.fromList(new ArrayList<AbstractMIBreakpoint>());
    for (ITRBreakpoint breakpoint : ListSequence.fromList(breakpoints)) {
      ListSequence.fromList(result).addElement((AbstractMIBreakpoint) breakpoint);
    }
    return result;
  }

  public void register(IMIBreakpointListener listener) {
    ListSequence.fromList(breakpointListeners).addElement(listener);
  }

  public void deregister(IMIBreakpointListener listener) {
    ListSequence.fromList(breakpointListeners).removeElement(listener);
  }

  public void addBreakpoint(AbstractMIBreakpoint breakpoint) {
    throw new UnsupportedOperationException();
  }

  public void removeBreakpoint(AbstractMIBreakpoint breakpoint) {
    throw new UnsupportedOperationException();
  }
}
